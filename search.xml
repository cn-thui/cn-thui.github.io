<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vector</title>
    <url>/2024/04/29/1.vector/</url>
    <content><![CDATA[<h1 id="vector-概念"><a class="markdownIt-Anchor" href="#vector-概念"></a> vector 概念</h1>
<ul>
<li><strong>从底层实现上</strong>：vector 是 C++ 标准模板库中的一个类模板，底层通过动态数组实现；</li>
<li><strong>从数据存储上</strong>：vector 是 C++ 标准库中的一种容器；</li>
</ul>
<h1 id="vector-特点"><a class="markdownIt-Anchor" href="#vector-特点"></a> vector 特点</h1>
<ul>
<li>**动态：**在创建时可以不用指定容器的大小，在程序运行的过程中，增加和删除元素会自动的调整容器的大小；也可以通过构造函数的重载来显示的指定容器的大小和初始值；</li>
<li>**连续：**容器内部使用连续的内存块来存储元素，可以通过索引来访问容器中的任何元素，所以在其尾部增加或者删除元素的时间复杂度为常数；</li>
</ul>
<h1 id="vector-构造函数"><a class="markdownIt-Anchor" href="#vector-构造函数"></a> vector 构造函数</h1>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，创建一个空的向量</span></span><br><span class="line"><span class="built_in">vector</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指定大小的向量，但不进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">( size_type count )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指定大小的向量，并使用指定值进行初始化</span></span><br><span class="line"><span class="built_in">vector</span>( size_type count, <span class="type">const</span> T&amp; value, <span class="type">const</span> Allocator&amp; alloc = <span class="built_in">Allocator</span>() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含迭代器范围内元素的向量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function"><span class="title">vector</span><span class="params">( InputIt first, InputIt last, <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始化列表来初始化向量</span></span><br><span class="line"><span class="built_in">vector</span>( std::initializer_list&lt;T&gt; init, <span class="type">const</span> Allocator&amp; alloc = <span class="built_in">Allocator</span>() );</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过拷贝构造函数来初始化向量</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp; other);</span><br></pre></td></tr></table></figure>
<h1 id="vector-操作函数"><a class="markdownIt-Anchor" href="#vector-操作函数"></a> vector 操作函数</h1>
<h2 id="插入和删除元素"><a class="markdownIt-Anchor" href="#插入和删除元素"></a> <strong>插入和删除元素</strong></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在末尾插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入元素</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, size_type count, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt</span>&gt;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, InputIt first, InputIt last)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator pos, std::initializer_list&lt;T&gt; init)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator pos)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="访问元素"><a class="markdownIt-Anchor" href="#访问元素"></a> <strong>访问元素</strong></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问第一个和最后一个元素</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问指定位置的元素</span></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type pos);</span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type pos) <span class="type">const</span>;</span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(size_type pos)</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">at</span><span class="params">(size_type pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指向第一个和最后一个元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="容量"><a class="markdownIt-Anchor" href="#容量"></a> <strong>容量</strong></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取容器中元素数量</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取容器的最大可容纳元素数量</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取容器当前分配的存储空间大小</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断容器是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变容器的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变容器大小并初始化为 value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type count, <span class="type">const</span> value_type&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放多余的存储空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="vector-迭代器"><a class="markdownIt-Anchor" href="#vector-迭代器"></a> vector 迭代器</h1>
<p><strong>迭代器：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">crbegin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">crend</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件IO</title>
    <url>/2024/05/10/1.%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<h1 id="1文件io是什么"><a class="markdownIt-Anchor" href="#1文件io是什么"></a> 1.文件IO是什么？</h1>
<p>Linux 的文件 IO 的 IO 其实就是 input and output，翻译过来就是输入和输出，那么文件 IO 就是对文件进行输入输出，其实就是修改文件。</p>
<h1 id="2文件io有什么作用"><a class="markdownIt-Anchor" href="#2文件io有什么作用"></a> 2.文件IO有什么作用？</h1>
<p>在程序运行的过程中，我们希望把某些有用的信息保存下来，或者是希望程序去读取某个文件的配置信息，从而达到不同的运行效果，这类操作都需要与文件进行交互，此时就需要使用到文件 IO。</p>
<h1 id="3文件io如何使用"><a class="markdownIt-Anchor" href="#3文件io如何使用"></a> 3.文件IO如何使用？</h1>
<p>在 Linux 操作系统中，提供了一系列文件 IO 的操作接口，其中使用的比较多的有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按要求打开文件并获取文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取数据流</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往文件中写入数据流</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件偏移量</span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对文件描述符进行控制操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对设备IO进行控制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>这些函数是操作系统提供的系统调用，实现了对文件IO的底层控制。要使用这些函数，通常需要包含相应的头文件，并在程序中进行错误处理。</p>
<p>在使用 C 语言和或 C++ 编程时，也可以使用标准库中封装好的 IO 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p>这些函数实际上是通过调用操作系统提供的底层系统接口来实现 IO 功能，所以它与 Linux 文件 IO 是一种调用与被调用的关系。</p>
<p>在一般情况下，我们可以使用C语言标准库中的文件IO函数来完成大部分文件IO操作，但在某些特殊情况下，可能需要直接调用Linux系统的文件IO函数来实现特定的功能或者进行优化性能。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2024/04/20/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/two-sum/description/">两数之和</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1枚举"><a class="markdownIt-Anchor" href="#1枚举"></a> 1.枚举</h2>
<p><strong>思路与方法</strong>：遍历数组，按顺序枚举出两个不同的值，然后求和判断是否等于目标值。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n^2)，n 为 nums 的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">size_t</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2哈希条件查找"><a class="markdownIt-Anchor" href="#2哈希条件查找"></a> 2.哈希+条件查找</h2>
<p><strong>思路与方法</strong>：构建一个哈希表，元素值为键，元素下标为值；开始遍历原数组，在遍历数组的每一个元素时，查询哈希表中是否存在该元素的伙伴，存在则将这两个元素的下标返回，如果不存在则将该元素插入到哈希表中供后续的元素进行查询。</p>
<ul>
<li>如果 b = target - a ，则称 b 为 a 的伙伴</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为 nums 的长度</li>
<li>空间复杂度：O(n)，n 为 nums 的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">size_t</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 查询当前元素在哈希表中是否存在伙伴</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(target - nums[i])) &#123;</span><br><span class="line">                <span class="comment">// 有伙伴，获取两个元素的下标</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(hash[target - nums[i]]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有伙伴，将当前元素插入哈希表中</span></span><br><span class="line">            hash.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的的数字</title>
    <url>/2024/04/28/11.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/single-number/description/">只出现一次的数字</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1异或运算"><a class="markdownIt-Anchor" href="#1异或运算"></a> 1.异或运算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 两个相等的值异或等于0</span></span><br><span class="line">            ans ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2024/04/23/10.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1枚举"><a class="markdownIt-Anchor" href="#1枚举"></a> 1.枚举</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> numsSize = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 记录最大利润</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">                <span class="comment">// 没有利润直接进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (prices[i] &gt;= prices[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算第i天买入，第j天卖出的利润</span></span><br><span class="line">                <span class="type">int</span> temp = prices[j] - prices[i];</span><br><span class="line">                <span class="comment">// 找出最大利润</span></span><br><span class="line">                <span class="keyword">if</span> (temp &gt; max) &#123;</span><br><span class="line">                    max = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2动态规划"><a class="markdownIt-Anchor" href="#2动态规划"></a> 2.动态规划</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> numsSize = prices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> profit_max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> price_min = prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 每天都看一下今天是不是历史最低点，若是则更新</span></span><br><span class="line">            price_min = <span class="built_in">min</span>(prices[i], price_min);</span><br><span class="line">            <span class="comment">// 每天都看一下我今天卖出能获取的最大利润是多少，如果比以往利润都大则更新</span></span><br><span class="line">            profit_max = <span class="built_in">max</span>(profit_max, prices[i] - price_min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素II</title>
    <url>/2024/04/29/14.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/">存在重复元素II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(nums[i]) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 找到相同值，返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没找到，插入键值</span></span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                <span class="comment">// 窗口开始滑动，擦除窗口外的值</span></span><br><span class="line">                hash.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2024/04/28/12.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/majority-element/description/">多数元素</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1摩尔投票"><a class="markdownIt-Anchor" href="#1摩尔投票"></a> 1.摩尔投票</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录票数</span></span><br><span class="line">        <span class="type">int</span> votes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录众数值</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 票数抵消为0时，将众数更新为当前元素</span></span><br><span class="line">                ans = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == ans) &#123;</span><br><span class="line">                <span class="comment">// 如果当前元素为众数，则票数+1</span></span><br><span class="line">                votes++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前元素不为众数，则票数-1</span></span><br><span class="line">                votes--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2024/04/29/13.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/contains-duplicate/description/">存在重复元素</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(i) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 找到了相同值，返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没找到，插入到尾部</span></span><br><span class="line">            hash.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有相同的值，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>汇总区间</title>
    <url>/2024/04/29/15.%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/summary-ranges/description/">汇总区间</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 记录区间头</span></span><br><span class="line">            <span class="type">int</span> front = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录区间尾</span></span><br><span class="line">            <span class="type">int</span> end = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (front &lt; end) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[front]) + <span class="string">&quot;-&gt;&quot;</span> +</span><br><span class="line">                              <span class="built_in">to_string</span>(nums[end]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[front]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>丢失的数字</title>
    <url>/2024/05/06/16.%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/missing-number/description/">丢失的数字</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [0, n]中元素的和与从 1 加到 n 的和的差值，就是缺失元素的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// i 为 数组元素的位置，从 1 开始</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            ans += i;</span><br><span class="line">            ans -= nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2枚举"><a class="markdownIt-Anchor" href="#2枚举"></a> 2.枚举</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; table;</span><br><span class="line">        <span class="comment">// 创建一个set容器将nums插入进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            table.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组的长度为 n 也就是数组的最大值</span></span><br><span class="line">        <span class="type">int</span> n = table.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 查询 [0, n] 中没有出现的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table.<span class="built_in">find</span>(i) == table.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>移动0</title>
    <url>/2024/05/07/17.%E7%A7%BB%E5%8A%A80/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/move-zeroes/description/">移动0</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 顺序查找为 0 的元素，不为 0 则退出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 与 i 后第一个不为0的元素进行交换</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2动态规划"><a class="markdownIt-Anchor" href="#2动态规划"></a> 2.动态规划</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录 0 的个数，也就是元素需要移动的距离</span></span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 当前元素为 0，不需要移动直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前不需要移动，直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将元素向前移动 n 个单位，并将该位置置为 0</span></span><br><span class="line">            nums[i - n] = nums[i];</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集</title>
    <url>/2024/05/07/19.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">两个数组的交集</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建数组存储交集元素</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// 创建哈希表进行条件判断</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化哈希表</span></span><br><span class="line">        hash.<span class="built_in">resize</span>(<span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将第一个数组的元素插入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums1[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 屏蔽第一个数组中相同的元素</span></span><br><span class="line">                hash[nums1[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查第二个数组元素有没有在哈希表中出现，出现则为交集元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length2; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums2[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 屏蔽第二个数组中相同的元素</span></span><br><span class="line">                hash[nums2[i]]++;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>区域和检索-数组不可变</title>
    <url>/2024/05/07/18.%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/">区域和检索-数组不可变</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1前缀和"><a class="markdownIt-Anchor" href="#1前缀和"></a> 1.前缀和</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化前缀和数组，长度比原数组长度多 1</span></span><br><span class="line">        arr.<span class="built_in">resize</span>(length + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化时遍历数组计算前缀和</span></span><br><span class="line">            arr[i + <span class="number">1</span>] = arr[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (arr[right + <span class="number">1</span>] - arr[left]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2枚举"><a class="markdownIt-Anchor" href="#2枚举"></a> 2.枚举</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        arr.<span class="built_in">resize</span>(length, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            arr[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>fopen()找不到文件</title>
    <url>/2024/05/10/2.fopen()%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在学习如何使用 C 标准库的 IO 函数时，写了一个程序，功能是往日志文件中打印十行时间信息，报出错误找不到文件，在此记录一下问题原因及解决方案。</p>
<h1 id="代码段"><a class="markdownIt-Anchor" href="#代码段"></a> <strong>代码段</strong></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    FILE* fd = fopen(<span class="string">&quot;~/project/log.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">time_t</span> current_time = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (current_time == (<span class="type">time_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转换为当地时间结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">localTime</span> =</span> localtime(&amp;current_time);</span><br><span class="line">        <span class="keyword">if</span> (localTime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;localtime&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印时间到日志中</span></span><br><span class="line">        <span class="type">int</span> writtenTime = <span class="built_in">fprintf</span>(fd, <span class="string">&quot;time:%s\n&quot;</span>, asctime(localTime));</span><br><span class="line">        <span class="keyword">if</span> (writtenTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fprintf&quot;</span>);</span><br><span class="line">            fclose(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="终端输出"><a class="markdownIt-Anchor" href="#终端输出"></a> 终端输出</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thui@master:~/project$ gcc a.c -o a.exe</span><br><span class="line">thui@master:~/project$ ./a.exe </span><br><span class="line">fopen: No such file or directory</span><br></pre></td></tr></table></figure>
<h1 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> <strong>问题原因</strong></h1>
<p>在UNIX系统中，<code>~</code> 不会被自动扩展为当前用户的家目录，所以无法找到文件。</p>
<h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取用户的家目录然后构建出日志文件路径即可</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *home_dir = getenv(<span class="string">&quot;HOME&quot;</span>);</span><br><span class="line">    <span class="type">char</span> log_path[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(log_path, <span class="keyword">sizeof</span>(log_path), <span class="string">&quot;%s/project/log.txt&quot;</span>, home_dir);</span><br><span class="line"></span><br><span class="line">    FILE *fd = fopen(log_path, <span class="string">&quot;a&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">time_t</span> current_time = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (current_time == (<span class="type">time_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">        	perror(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 转换为当地时间结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">localTime</span> =</span> localtime(&amp;current_time);</span><br><span class="line">        <span class="keyword">if</span> (localTime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;localtime&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 打印时间到日志中</span></span><br><span class="line">        <span class="type">int</span> writtenTime = <span class="built_in">fprintf</span>(fd, <span class="string">&quot;time:%s\n&quot;</span>, asctime(localTime));</span><br><span class="line">        <span class="keyword">if</span> (writtenTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fprintf&quot;</span>);</span><br><span class="line">            fclose(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>Linux</tag>
        <tag>文件IO</tag>
      </tags>
  </entry>
  <entry>
    <title>删除有序数组中的重复项</title>
    <url>/2024/04/20/2.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">删除有序数组中的重复项</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> slow_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fast_index = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 结束条件为快指针走到了数组的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast_index &lt; numsSize) &#123;</span><br><span class="line">        <span class="comment">// 如果慢指针比快指针的值小，则将快指针的值填充进慢指针的后面</span></span><br><span class="line">        <span class="keyword">if</span> (nums[slow_index] &lt; nums[fast_index]) &#123;</span><br><span class="line">            nums[++slow_index] = nums[fast_index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果慢指针与快指针的值相同，则快指针往前走，慢指针不动</span></span><br><span class="line">        fast_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组元素的个数等于数组最后一个元素索引加一</span></span><br><span class="line">    <span class="type">int</span> ans = slow_index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集II</title>
    <url>/2024/05/08/20.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/">两个数组的交集II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        hash.<span class="built_in">resize</span>(<span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; i++) &#123;</span><br><span class="line">            <span class="comment">// 记录第一个数组中元素出现的个数</span></span><br><span class="line">            hash[nums1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length2; i++) &#123;</span><br><span class="line">            <span class="comment">// 检查第二个数组元素是否为交集元素</span></span><br><span class="line">            <span class="keyword">if</span> (hash[nums2[i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">                hash[nums2[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2双指针"><a class="markdownIt-Anchor" href="#2双指针"></a> 2.双指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果给定的数组已经排好序呢？你将如何优化你的算法？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设已经排好序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 相同元素插入，否则元素值小的指针先往前走</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>找到所有数组中消失的数字</title>
    <url>/2024/05/08/22.%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">找到所有数组中消失的数字</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希预处理遍历搜索"><a class="markdownIt-Anchor" href="#1哈希预处理遍历搜索"></a> 1.哈希预处理+遍历+搜索</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="comment">// 数组的长度 = 数组的最大值 = 区间的最大值</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            hash[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>第三大的数</title>
    <url>/2024/05/08/21.%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/third-maximum-number/description/">第三大的数</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1动态规划"><a class="markdownIt-Anchor" href="#1动态规划"></a> 1.动态规划</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 保证三个数比数组中任何元素都小</span></span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> first = LONG_MIN;</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> secend = LONG_MIN;</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> third = LONG_MIN;</span><br><span class="line">        <span class="comment">// 记录更新次数</span></span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 去重，不进行更新</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == first || nums[i] == secend || nums[i] == third) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据遍历元素的大小进行更新</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; first) &#123;</span><br><span class="line">                third = secend;</span><br><span class="line">                secend = first;</span><br><span class="line">                first = nums[i];</span><br><span class="line">                n++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; secend) &#123;</span><br><span class="line">                third = secend;</span><br><span class="line">                secend = nums[i];</span><br><span class="line">                n++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; third) &#123;</span><br><span class="line">                third = nums[i];</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当更新次数小于3时说明没有第三大的数字，按要求返回</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>分发饼干</title>
    <url>/2024/05/08/23.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/assign-cookies/description/">分发饼干</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何能满足满足最多的小孩？为每个小孩找到一个能满足胃口且最合适的饼干就可以满足尽量多的小孩；如果按照顺序来分，那么没有被分配出去且刚好能满足胃口的饼干就是最合适的饼干；可以从小到大分，也可以从大到小分。</li>
<li><strong>算法分析</strong>：使用了排序算法，时间复杂度：O（nlogn），其次使用了循环，时间复杂度：O（n），综合来看时间复杂度为：O（nlogn），其中 n 为 g 或 s 数组长度的较大值；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 双指针，分别指向小孩和饼干</span></span><br><span class="line">        <span class="type">int</span> indexG = <span class="number">0</span>， indexS = <span class="number">0</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 退出条件为已经没有饼干可以满足后面的小孩了或者是每个小孩都被满足了</span></span><br><span class="line">        <span class="keyword">while</span> (indexS &lt; s.<span class="built_in">size</span>() &amp;&amp; indexG &lt; g.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[indexS] &gt;= g[indexG]) &#123;</span><br><span class="line">                <span class="comment">// 满足了小孩，开始为下一个小孩寻找饼干，满足人数加一</span></span><br><span class="line">                indexG++;</span><br><span class="line">                indexS++;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没满足小孩，看看下一个饼干是否可以满足</span></span><br><span class="line">                indexS++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿的周长</title>
    <url>/2024/05/08/24.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/island-perimeter/description/">岛屿的周长</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：一个格子有四条边，如果上下左右有一方相邻则减少一条边，那么在遍历数组为陆地时需要处理子问题：当前陆地的上下左右是否为陆地，如果为陆地则减少一条边；陆地与陆地的相邻是相互的，所以判断一个陆地上方有相邻时，上方陆地也会判断出下方陆地相邻，那么上下判断可以只执行其一，减少一条边变为减少两条边（减少的一条边为当前格子的边，另一条边为相邻格子的边），左右同理；所以只需要遍历每个格子并判断右方和下方是否有相邻的陆地，并进行边的计算，最后累加完就是岛屿的周长。</li>
<li><strong>算法分析</strong>：遍历二维数组，时间复杂度：O（m × n）；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rows = grid.<span class="built_in">size</span>(), cols = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前元素为陆地，添加四条边并进行右方和下方判断</span></span><br><span class="line">                    cnt += <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i != rows - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                            cnt -= <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j != cols - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                            cnt -= <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最大连续1的个数</title>
    <url>/2024/05/08/25.%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones/description/">最大连续1的个数</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何得到最大连续 1 的个数？将连续为 1 的数段累加后与当前出现最大的连续 1 的个数进行比较，如果超过则更新出现最大的连续 1 的个数，如果没超过继续遍历数组，如果为 0 则累加的值作废；</li>
<li><strong>算法分析</strong>：只需要一次遍历，时间复杂度：O（n），使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                max = cnt &gt; max ? cnt : max;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>提莫攻击</title>
    <url>/2024/05/09/26.%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/teemo-attacking/description/">提莫攻击</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何得到艾希的总中毒时间？当艾希中毒后的中毒时间内没有再次中毒，那么中毒时间就是完整的；当艾希中毒后中毒时间内又再次中毒，那么中毒时间不完整，需要进行计算；最终将每次中毒的时间进行累加就可以得到艾希的总中毒时间。</li>
<li><strong>算法分析</strong>：只需要一次遍历，时间复杂度：O（n）；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPoisonedDuration</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; timeSeries, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = timeSeries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sumTime = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算第一次中毒的结束时间</span></span><br><span class="line">        <span class="type">int</span> endTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算中毒的结束时间</span></span><br><span class="line">            endTime = timeSeries[i] + duration - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (endTime &lt; timeSeries[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 中毒时间完整</span></span><br><span class="line">                sumTime += duration;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中毒时间不完整</span></span><br><span class="line">                sumTime = sumTime + timeSeries[i + <span class="number">1</span>] - timeSeries[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一次攻击完后中毒时间总是完整的</span></span><br><span class="line">        sumTime += duration;</span><br><span class="line">        <span class="keyword">return</span> sumTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素I</title>
    <url>/2024/05/09/27.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/next-greater-element-i/description/">下一个更大元素I</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：在第二个数组中查询第一个数组的元素，然后找到其后方第一个比该元素大的值，并按照要求插入；依次将第一个数组中的元素查找完毕即可。</li>
<li><strong>算法分析</strong>：双层循环，时间复杂度：O（n x m）；不考虑返回数组，使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums1.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nextMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">find</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), nums1[i]);</span><br><span class="line">            <span class="keyword">while</span> (it != nums2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 找到下一个更大的元素，插入元素</span></span><br><span class="line">                <span class="keyword">if</span> (*it &gt; nums1[i]) &#123;</span><br><span class="line">                    nextMax.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历到容器的末尾还没有找到，插入-1</span></span><br><span class="line">                <span class="keyword">if</span> (it == nums2.<span class="built_in">end</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    nextMax.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>相对名次</title>
    <url>/2024/05/12/29.%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/relative-ranks/description/">相对名次</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2>
<ul>
<li><strong>算法思路</strong>：如何获取每位运动员的名次？可以按顺序进行查找，先找到分数最高的运动员进行颁奖，然后找到分数第二的进行颁奖，直到每位运动员都拿到对应的名次为止。</li>
<li><strong>算法分析</strong>：双循环遍历，时间复杂度：O（n^2）；不考虑返回数组，使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组的长度 = 运动员的个数 = 运动员的最低名次</span></span><br><span class="line">        <span class="type">int</span> length = score.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        ans.<span class="built_in">resize</span>(length, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找出获得第 i 名的运动员</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">            <span class="comment">// 找出该名运动员对应的下标</span></span><br><span class="line">            <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (score[j] &gt; score[n]) &#123;</span><br><span class="line">                    n = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 给出这名运动员的名次 i 所对应的奖励</span></span><br><span class="line">            <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: ans[n] = <span class="string">&quot;Gold Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: ans[n] = <span class="string">&quot;Silver Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: ans[n] = <span class="string">&quot;Bronze Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: ans[n] = <span class="built_in">to_string</span>(i); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 抹除掉这名运动员成绩</span></span><br><span class="line">            score[n] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="哈希排序"><a class="markdownIt-Anchor" href="#哈希排序"></a> 哈希+排序</h2>
<ul>
<li><strong>算法思路</strong>：如何获取每位运动员的名次？可以将分数进行排序，然后依次分配名次，但是分配名次时需要知道成绩对应的运动员信息，可以使用哈希表，将分数作为键，将运动员信息作为值，然后对键进行排序，然后依次分配名次，分配名次时获取运动员信息即可。</li>
<li><strong>算法分析</strong>：map 插入函数的底层基于红黑树实现，时间复杂度：O（log n），循环遍历时间复杂度：O（n），综合来看时间复杂度：O（n）；不考虑返回数组，构建了一个哈希表，空间复杂度：O（n）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组的长度 = 运动员的个数 = 运动员的最低名次</span></span><br><span class="line">        <span class="type">int</span> length = score.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        ans.<span class="built_in">resize</span>(length, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="comment">// 使用map构建哈希表，因为map会自动根据键的大小进行排序</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(score[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为遍历map时从最小值开始，所以从最低名次开始分配</span></span><br><span class="line">        <span class="type">int</span> i = length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : hash) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: ans[it.second] = <span class="string">&quot;Gold Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: ans[it.second] = <span class="string">&quot;Silver Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: ans[it.second] = <span class="string">&quot;Bronze Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: ans[it.second] = <span class="built_in">to_string</span>(i); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>键盘行</title>
    <url>/2024/05/11/28.%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/keyboard-row/description/">键盘行</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何只返回可以使用键盘同一行打印的单词？首先需要遍历每个单词，并对每个单词的每个字符判定，是否属于同一行，如果是则存储返回数组，不是则开始遍历下一个单词；此时需要解决两个子问题：（1）怎么获取到单词中字符的行号？（2）怎么判定字符属于同一行？先解决第一个问题：使用一个数组哈希，使用 26 个字母的 ASCII 值减去小写字母 a 的 ASCII 值即为数组的下标，而下标对应的元素的值为该字母所属的行号，那么在获取到字符时先转换为小写，然后获取其 ASCII 值并进行计算就可以获取该字符的行号；第二个问题：如果使用字符两两判定实现起来太过复杂，将问题转为，当字符串中的每个字符都和第一个字符在同一行时，那么这个字符串就是符合要求的，然后循环进行判定即可。</li>
<li><strong>算法分析</strong>：需要遍历所有的字符，时间复杂度：O（n），n 为字符串数组中所有字符的个数；除开返回数组外，使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储符合要求的字符串</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="comment">// 数组哈希</span></span><br><span class="line">        string rowIndex = <span class="string">&quot;12210111011122000010020202&quot;</span>;</span><br><span class="line">        <span class="comment">// 循环遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 创建标志位判断该字符串是否符合要求</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 获取字符串第一个字符所在的行号</span></span><br><span class="line">            <span class="type">char</span> startLine = rowIndex[<span class="built_in">tolower</span>(words[i][<span class="number">0</span>]) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="comment">// 循环遍历字符串中的每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 判定字符是否与第一个字符属于同一行</span></span><br><span class="line">                <span class="keyword">if</span> (rowIndex[<span class="built_in">tolower</span>(words[i][j]) - <span class="string">&#x27;a&#x27;</span>] != startLine) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个字符串判定结束后，将符合要求的字符串插入返回数组</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>移除元素</title>
    <url>/2024/04/20/3.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 从左开始从查找值为 val 的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] != val) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右开始查找值不为 val 的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[right] == val) &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将左右调换</span></span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边界与右边界相遇时即为左边界即为数组修改后的长度</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数组拆分</title>
    <url>/2024/05/13/30.%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/array-partition/description/">数组拆分</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1排序贪心"><a class="markdownIt-Anchor" href="#1排序贪心"></a> 1.排序+贪心</h2>
<ul>
<li><strong>算法思路</strong>：如何获得总和最大？每一个数对中都会取较小的值，而另外一个值则一定排除再外，那么我只需要给这个数匹配一个大于它且最接近的数，那么这样的话，最小的值应该匹配第二小的值，剩下的数同理分析，所以将数组进行排序后可以发现，累加到和中的数字其实就是数组中偶数下标对应的元素。</li>
<li><strong>算法分析</strong>：sort() 函数底层使用快速排序或者堆排序，时间复杂度：O（nlogn），循环遍历时间复杂度：O（n），综合来看时间复杂度：O（nlogn）；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arrayPairSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            minSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>重塑矩阵</title>
    <url>/2024/05/13/31.%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/reshape-the-matrix/description/">重塑矩阵</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1flatten映射"><a class="markdownIt-Anchor" href="#1flatten映射"></a> 1.flatten映射</h2>
<ul>
<li><strong>算法思路</strong>：用两个下标进行标注，遍历原数组的元素插入重塑数组，当重塑数组的第一行插入满了以后切换进入下一行，直到插入完毕为止，先将原数组映射为一维数组，获得其下标，将下标再映射为目标数组，因为映射计算是可逆的，所以可以直接将原数组赋值给目标数组。</li>
<li><strong>算法分析</strong>：遍历二维矩阵，时间复杂度：O（m x n）；不考虑返回数组，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span> rows = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(rows * cols != r * c)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">againArr</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++) &#123;</span><br><span class="line">            <span class="comment">// 行 = 一维数组下标 / 最大列</span></span><br><span class="line">            <span class="comment">// 列 = 一维数组下标 % 最大列</span></span><br><span class="line">            againArr[i / c][i % c] = mat[i / cols][i % cols];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> againArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2024/05/15/33.%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/longest-harmonious-subsequence/description/">最长和谐子序列</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希条件查找"><a class="markdownIt-Anchor" href="#1哈希条件查找"></a> 1.哈希+条件查找</h2>
<p><strong>思路与方法</strong>：首先构建一个哈希表，键为原数组元素的值，值为该元素出现的次数；将原数组映射为哈希表后，对哈希表进行遍历，在遍历每一个元素时，查询哈希表中是否存在该元素的伙伴，如果存在则获取两个元素出现次数的和，满足条件和中的最大值即为最长子序列的长度。</p>
<ul>
<li>如果 b = a + 1，则称 b 为 a 的伙伴</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为 nums 的长度</li>
<li>空间复杂度：O(n)，n 为 nums 的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建哈希表</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            hash[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : hash) &#123;</span><br><span class="line">            <span class="comment">// 查询当前元素是否有伙伴</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(it.first + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 获取这对元素构成的子序列长度</span></span><br><span class="line">                <span class="type">int</span> sum = it.second + hash[it.first + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 获取最长子序列的长度</span></span><br><span class="line">                ans = sum &gt; ans ? sum : ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>分糖果</title>
    <url>/2024/05/15/32.%E5%88%86%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/distribute-candies/description/">分糖果</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希计数"><a class="markdownIt-Anchor" href="#1哈希计数"></a> 1.哈希+计数</h2>
<ul>
<li><strong>算法思路</strong>：需要在尽可能少的糖果中吃到尽可能多的类型，我们可以遍历数组，每遇到一种不同的糖果就吃一颗，并且对吃的颗数进行计数；那么出现了子问题：怎么判断糖果的类型不同？可以使用哈希表进行去重，当哈希表中已经记录了这颗糖果时就代表已经吃过了，没记录就代表没吃过；最后在计数的同时判断有没有超过医生建议的数量即可。</li>
<li><strong>算法分析</strong>：一次循环遍历，时间复杂度：O（n）；创建哈希表进行去重，空间复杂度：O（n）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = candyType.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 记录吃到不同类型糖果的数量</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 没吃过，可以吃</span></span><br><span class="line">            <span class="keyword">if</span> (hash[candyType[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                hash[candyType[i]]++;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="comment">// 遵循医生建议，最多只吃一半</span></span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2排序计数"><a class="markdownIt-Anchor" href="#2排序计数"></a> 2.排序+计数</h2>
<ul>
<li>xxxxxxxxxx class Solution {public:    int findLHS(vector<int>&amp; nums) {        // 构建哈希表        unordered_map&lt;int, int&gt; hash;        for (int num : nums) {            hash[num]++;        }        int ans = 0;        for (const auto&amp; it : hash) {            // 查询当前元素是否有伙伴            if (hash.count(it.first + 1)) {                // 获取这对元素构成的子序列长度                int sum = it.second + hash[it.first + 1];                // 获取最长子序列的长度                ans = sum &gt; ans ? sum : ans;            }        }        return ans;    }};cpp</li>
<li><strong>算法分析</strong>：使用 sort() 排序，时间复杂度：O（nlogn），一次循环遍历，时间复杂度：O（n），综合时间复杂度：O（nlogn）；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = candyType.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 记录吃到不同类型糖果的数量，且假定已经吃了一颗</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(candyType.<span class="built_in">begin</span>(), candyType.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 第一颗总是可以吃的，从第二颗开始判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 与上一颗不同，可以吃</span></span><br><span class="line">            <span class="keyword">if</span> (candyType[i] != candyType[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>区间加法II</title>
    <url>/2024/05/15/34.%E5%8C%BA%E9%97%B4%E5%8A%A0%E6%B3%95II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/range-addition-ii/description/">区间加法II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<p><strong>方法与思路</strong>：对于每一次操作都需要对指定区间进行加一，每次操作都覆盖到的区域即为矩阵中的最大值，对于操作数来说，每次操作都能覆盖的范围其实就是操作数中的最小值，只需要遍历数组找到行和列对应操作数的最小值即可。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为 ops 的行数</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> rows = ops.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到行操作数的最小值</span></span><br><span class="line">           	m = <span class="built_in">min</span>(m, ops[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 找到列操作数的最小值</span></span><br><span class="line">            n = <span class="built_in">min</span>(n, ops[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>两个列表的最小索引总和</title>
    <url>/2024/05/15/35.%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/minimum-index-sum-of-two-lists/description/">两个列表的最小索引总和</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希条件查找"><a class="markdownIt-Anchor" href="#1哈希条件查找"></a> 1.哈希+条件查找</h2>
<p><strong>方法与思路</strong>：构建一个哈希表，将餐厅名作为键，索引作为值，将第一个数组映射为哈希表；对第二个数组进行遍历，在遍历每一个元素时，都对哈希表进行查找，哈希表中是否存在与当前元素相同的键，如果存在则获取两个元素的索引和，并判断该索引和是否为满足条件索引和的最小值，如果是最小值，则更新最小值并重置数组，如果与之前的最小值相同，则直接将该元素插入。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为两个数组中较长数组的长度</li>
<li>空间复杂度：O(n)，n 为两个数组中较短数组的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="comment">// 将短的数组映射为哈希表，节省内存</span></span><br><span class="line">        vector&lt;string&gt;&amp; shortList = list1.<span class="built_in">size</span>() &lt; list2.<span class="built_in">size</span>() ? list1 : list2;</span><br><span class="line">        vector&lt;string&gt;&amp; longList = list1.<span class="built_in">size</span>() &gt;= list2.<span class="built_in">size</span>() ? list1 : list2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shortList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            hash[shortList[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小索引和</span></span><br><span class="line">        <span class="type">int</span> minIndexSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; longList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 查询到相同的餐厅</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(longList[i])) &#123;</span><br><span class="line">                <span class="type">int</span> indexSum = i + hash[longList[i]];</span><br><span class="line">                <span class="comment">// 判断索引和与最小索引和的关系</span></span><br><span class="line">                <span class="keyword">if</span> (indexSum &lt; minIndexSum) &#123;</span><br><span class="line">                    <span class="comment">// 更新最小索引和并且重置数组</span></span><br><span class="line">                    minIndexSum = indexSum;</span><br><span class="line">                    ans = &#123;longList[i]&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexSum == minIndexSum) &#123;</span><br><span class="line">                    <span class="comment">// 插入数组</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(longList[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>种花问题</title>
    <url>/2024/05/16/36.%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/can-place-flowers/description/">种花问题</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1贪心"><a class="markdownIt-Anchor" href="#1贪心"></a> 1.贪心</h2>
<p><strong>方法与思路</strong>：假设花坛中有一段连续的地块没有花，连续地块的数量为 n ，这个连续的地块最多可以种植 ( ( ( n - 2 ) + 1 ) / 2 ) 朵花；但如果地块处于花坛的头部或者尾部，则最多可以种植 ( ( ( n - 1 ) + 1 ) / 2 ) 朵花，那么只需要找出花坛中有多少个这样的连续地块并获取每一个连续地块的数量 n 进行计算即可；</p>
<ul>
<li>为了统一计算方式为 ( ( ( n - 2 ) + 1 ) / 2 )，我们可以在找到头部或者尾部地块时多加一个地块，在计算时扣除掉即可</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前地块没有花</span></span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; i == length - <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> || i == length - <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前已经是最后一个地块或下一个地块有花，需要进行计算</span></span><br><span class="line">            <span class="keyword">if</span> (i == length - <span class="number">1</span> || flowerbed[i + <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    sum += (cnt - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> ans = (sum &gt;= n ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2024/04/20/5.%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/plus-one/description/">加一</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">plusOne</span><span class="params">(<span class="type">int</span>* digits, <span class="type">int</span> digitsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = digitsSize;</span><br><span class="line">    <span class="comment">// 逆序遍历数组元素，判定是否需要增加数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = digitsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                *returnSize = digitsSize + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请内存用以存储新数组</span></span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组长度需要增加，此时只有第一个元素为1，其他元素都为0</span></span><br><span class="line">    <span class="keyword">if</span> (*returnSize &gt; digitsSize) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要增加，将原数组数组拷贝到 ans 中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ans, digits, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">    <span class="comment">// 逆序遍历元素进行修改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = *returnSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索插入位置</title>
    <url>/2024/04/20/4.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/search-insert-position/description/">搜索插入位置</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1二分查找"><a class="markdownIt-Anchor" href="#1二分查找"></a> 1.二分查找</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(x, y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 获取中间索引</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 更新右边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 更新左边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回目标值的索引</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回插入位置的索引</span></span><br><span class="line">    <span class="keyword">return</span> MIN(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 目标值小于数组最小值</span></span><br><span class="line">    <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 目标值大于数组最大值</span></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[numsSize - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>将有序数组转换为二叉搜索树</title>
    <url>/2024/04/22/7.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">将有序数组转换为二叉搜索树</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1中序遍历"><a class="markdownIt-Anchor" href="#1中序遍历"></a> 1.中序遍历</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">function</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右相遇时结束递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取中间元素索引</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 创建节点，并初始化值为中间元素的值</span></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        <span class="comment">// 递归获取节点的左子节点</span></span><br><span class="line">        node-&gt;left = <span class="built_in">function</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归获取节点的右子节点</span></span><br><span class="line">        node-&gt;right = <span class="built_in">function</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">function</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/2024/04/22/6.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针从头开始填充"><a class="markdownIt-Anchor" href="#1双指针从头开始填充"></a> 1.双指针（从头开始填充）</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理特殊情况****************************/</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums2.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m - <span class="number">1</span>] &lt; nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[<span class="number">0</span>] &gt; nums2[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + <span class="number">0</span>, nums1.<span class="built_in">begin</span>() + m, nums1.<span class="built_in">begin</span>() + n);</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理一般情况****************************/</span></span><br><span class="line">        <span class="type">int</span> length = m + n;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束条件为其中一个数组已经填充完毕</span></span><br><span class="line">        <span class="keyword">while</span> (index1 ！= m &amp;&amp; index2 != n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[index1] &lt;= nums2[index2]) &#123;</span><br><span class="line">                nums[index++] = nums1[index1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">                nums[index++] = nums2[index2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组1填充完毕，将数组2剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + index2, nums2.<span class="built_in">begin</span>() + n,</span><br><span class="line">                      nums.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组2填充完毕，将数组1剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + index1, nums1.<span class="built_in">begin</span>() + m,</span><br><span class="line">                      nums.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将合并后的数组拷贝到数组1中</span></span><br><span class="line">        <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2双指针从尾开始填充"><a class="markdownIt-Anchor" href="#2双指针从尾开始填充"></a> 2.双指针（从尾开始填充）</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理特殊情况****************************/</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums2.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m - <span class="number">1</span>] &lt; nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[<span class="number">0</span>] &gt; nums2[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + <span class="number">0</span>, nums1.<span class="built_in">begin</span>() + m, nums1.<span class="built_in">begin</span>() + n);</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理一般情况****************************/</span></span><br><span class="line">        <span class="type">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index2 = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束条件为某个数组已经填充完毕</span></span><br><span class="line">        <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> &amp;&amp; index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[index1] &gt;= nums2[index2]) &#123;</span><br><span class="line">                nums1[index--] = nums1[index1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[index--] = nums2[index2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组1填充完毕，将数组2剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[index--] = nums2[index2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组2填充完毕，将数组1剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[index--] = nums1[index1--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3排序"><a class="markdownIt-Anchor" href="#3排序"></a> 3.排序</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums2.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m - <span class="number">1</span>] &lt; nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[<span class="number">0</span>] &gt; nums2[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + <span class="number">0</span>, nums1.<span class="built_in">begin</span>() + m, nums1.<span class="built_in">begin</span>() + n);</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理一般情况</span></span><br><span class="line">        std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">        std::<span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角</title>
    <url>/2024/04/22/8.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/pascals-triangle/description/">杨辉三角</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化行容器的大小</span></span><br><span class="line">            nums[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 初始化行第一个元素和最后一个元素为1</span></span><br><span class="line">            nums[i][<span class="number">0</span>] = nums[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找到每一行的中间靠右元素的下标</span></span><br><span class="line">            <span class="type">int</span> mid_right = (i / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算需要填充数据位置及其大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; mid_right; j++) &#123;</span><br><span class="line">                nums[i][j] = nums[i][i - j] =</span><br><span class="line">                    nums[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角II</title>
    <url>/2024/04/23/9.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">杨辉三角II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 生成一个 newRows 行的杨辉三角并返回</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化行容器的大小</span></span><br><span class="line">            nums[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 初始化行第一个元素和最后一个元素为1</span></span><br><span class="line">            nums[i][<span class="number">0</span>] = nums[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找到每一行的中间靠右元素的下标</span></span><br><span class="line">            <span class="type">int</span> mid_right = (i / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算需要填充数据位置及其大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; mid_right; j++) &#123;</span><br><span class="line">                nums[i][j] = nums[i][i - j] =</span><br><span class="line">                    nums[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取需要构建杨辉三角的大小</span></span><br><span class="line">        <span class="type">int</span> size = rowIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 声明一个二维容器用来接收生成的杨辉三角</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(size);</span><br><span class="line">        <span class="comment">// 调用函数生成杨辉三角并接收</span></span><br><span class="line">        nums = <span class="built_in">generate</span>(size);</span><br><span class="line">        <span class="comment">// 返回目标行</span></span><br><span class="line">        <span class="keyword">return</span> nums[rowIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo环境搭建</title>
    <url>/2024/04/20/Hexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="1-安装-nodejs-和-git"><a class="markdownIt-Anchor" href="#1-安装-nodejs-和-git"></a> 1. 安装 Node.js 和 Git</h1>
<p>首先，确保你的计算机上安装了 <code>Node.js</code> 和 <code>Git</code>。你可以在它们的官方网站上找到适合你操作系统的安装程序，并按照说明进行安装。</p>
<ul>
<li><a href="https://nodejs.org/">Node.js 官方网站</a></li>
<li><a href="https://git-scm.com/">Git 官方网站</a></li>
</ul>
<h1 id="2创建-github-page"><a class="markdownIt-Anchor" href="#2创建-github-page"></a> 2.创建 GitHub Page</h1>
<p>首先，登录你的 GitHub 账号，然后点击页面右上角的 “New” 按钮来创建一个新的仓库。仓库名为 <code>username.github.io</code>，其中 <code>username</code> 是你的 GitHub 用户名。这样的命名方式可以让你的博客成为 GitHub Pages 的一部分。</p>
<h1 id="3绑定-github-ssh-keys"><a class="markdownIt-Anchor" href="#3绑定-github-ssh-keys"></a> 3.绑定 Github SSH Keys</h1>
<p>为了将你的本地 Git 仓库与 GitHub 关联，你需要添加 SSH 密钥到你的 GitHub 帐户中。具体操作请查看：</p>
<ul>
<li><a href="https://cn-thui.github.io/2024/04/20/%E5%85%B6%E4%BB%96/SSH%20%E8%BF%9E%E6%8E%A5/">SSH 连接</a></li>
</ul>
<h1 id="4-安装-hexo-客户端"><a class="markdownIt-Anchor" href="#4-安装-hexo-客户端"></a> 4. 安装 Hexo 客户端</h1>
<p>打开命令行（或终端），运行以下命令来安装 Hexo：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>这将会全局安装 Hexo 命令行工具。</p>
<h1 id="5初始化-hexo-项目"><a class="markdownIt-Anchor" href="#5初始化-hexo-项目"></a> 5.初始化 Hexo 项目</h1>
<p>选择一个你喜欢的文件夹，进入该文件夹打开 <code>git bash</code> ，并运行以下命令来创建一个新的 Hexo 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure>
<p>这将会在当前文件夹下创建一个名为 <code>myblog</code> 的文件夹，并在其中初始化一个新的 Hexo 项目。</p>
<h1 id="6安装-hexo-依赖"><a class="markdownIt-Anchor" href="#6安装-hexo-依赖"></a> 6.安装 Hexo 依赖</h1>
<p>在 Hexo 项目文件夹中打开 <code>git bash</code>，运行以下命令来安装项目所需的依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h1 id="7hexo-关联-github-pages"><a class="markdownIt-Anchor" href="#7hexo-关联-github-pages"></a> 7.Hexo 关联 Github pages</h1>
<p>打开 Hexo 项目目录中的 <code>_config.yml</code> 文件，并在 <code>deploy</code> 部分配置部署设置。您可以使用 Git 或 GitHub Pages 进行部署。</p>
<p>若要部署到 GitHub Pages，请添加以下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">&lt;仓库</span> <span class="string">URL&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h1 id="8检查环境搭建是否成功"><a class="markdownIt-Anchor" href="#8检查环境搭建是否成功"></a> 8.检查环境搭建是否成功</h1>
<p>进入创建好的 Hexo 项目中打开 <code>git bash</code>，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>若 GitHub Page 中内容被更新，则说明 Hexo 环境搭建成功。</p>
<p>至此，您已经搭建了与 GitHub 关联的 Hexo 博客。您可以继续撰写和发布博客内容，每当有更改时，只需重新生成并部署您的站点到 GitHub。</p>
]]></content>
  </entry>
  <entry>
    <title>PicGo+Typero+GitHub搭建图床</title>
    <url>/2024/05/14/PicGo+Typero+GitHub/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在写博客时经常需要插入图片，图片插入后一般保存在本地，部署到服务器上之后，访问博客图片是无法显示的；为了解决这个问题，可以把图片上传到图床上，并转义为 URL 路径后插入到博客中；这样部署到服务器上后，访问博客就可以正常显示图片了；在这里记录一下如何使用 PicGo+Typero+GitHub 进行图床的搭建，并记录其中出现的一些问题，避免遗忘。</p>
<h1 id="搭建步骤"><a class="markdownIt-Anchor" href="#搭建步骤"></a> 搭建步骤</h1>
<h2 id="1创建仓库"><a class="markdownIt-Anchor" href="#1创建仓库"></a> 1.创建仓库</h2>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405142259930.png" alt="image-20240514213423838" /></p>
<h2 id="2picgo配置"><a class="markdownIt-Anchor" href="#2picgo配置"></a> 2.PicGo配置</h2>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405142259931.png" alt="image-20240514214747276" /></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">设定仓库名:&lt;github用户名/仓库名称&gt;</span><br><span class="line">设定分支名:&lt;上传分支&gt;</span><br><span class="line">设定Token:&lt;github令牌&gt;				  </span><br><span class="line">指定存储路径: &lt;存储到仓库的位置&gt;</span><br><span class="line">设定自定义域名: &lt;https://cdn.jsdelivr.net/gh/github用户名/仓库名称@上传分支&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有 GitHub 令牌的话可以去 GitHub 官网生成一个，注意令牌需要 repo 的全部权限</li>
<li>自定义域名是将 GitHub 中的图片映射到 JsDelivr 中获得的 URL 域名前缀，按照格式进行设定即可</li>
</ul>
<h2 id="3picgo-安装-compress-插件"><a class="markdownIt-Anchor" href="#3picgo-安装-compress-插件"></a> 3.PicGo 安装 Compress 插件</h2>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405142259932.png" alt="image-20240514224106465" /></p>
<ul>
<li>在插件设置中搜索 compress 然后点击安装即可，如果一直没有安装成功有可能是访问不了外网或者是本地没有安装 nodejs</li>
<li>一定要使用 PicGo 的稳定版本安装这个插件，使用最新版本的 PicGo 后续可能出现上传图片失败的情况</li>
</ul>
<h2 id="4compree配置启用"><a class="markdownIt-Anchor" href="#4compree配置启用"></a> 4.Compree配置启用</h2>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405142259933.png" alt="image-20240514224455688" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405142259934.png" alt="image-20240514224416776" /></p>
<ul>
<li>配置key需要进入 <a href="https://tinify.com/dashboard/api">Tinify官网网站</a> 获取 API Key，没有账号使用邮箱注册一个即可</li>
<li>配置完成后启用 transformer - compress 即可</li>
</ul>
<h2 id="5typero配置"><a class="markdownIt-Anchor" href="#5typero配置"></a> 5.Typero配置</h2>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405142259935.png" alt="image-20240514225441983" /></p>
<ul>
<li>打开偏好设置选择图像，配置上传服务为 PicGo ，并配置 PicGo.exe 的本地路径</li>
</ul>
<h2 id="6上传图片"><a class="markdownIt-Anchor" href="#6上传图片"></a> 6.上传图片</h2>
<ul>
<li>可以直接右击图片选择上传，上传成功后 Typero 上方会提示上传成功，此时图片的地址会变为一个 URL 域名；进入 GitHub 仓库中，会发现博客中的图片已经被上传到仓库中；正常部署文章到服务器后可以看到图片正常显示。</li>
</ul>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<ul>
<li>Typero 负责调用 PicGo.exe 来进行图片的上传</li>
<li>PicGo 负责调用 compress 插件来处理博客中的图片并按照设定上传到 GitHub 仓库中</li>
<li>Compress 负责调用 Tinify 的 API 来对图片进行压缩（Tinify 每个月能免费压缩500张图片）</li>
<li>GitHub 负责存储被上传的图片</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SSH安装配置连接（Windows）</title>
    <url>/2024/04/20/SSH%20%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="1安装-ssh-客户端"><a class="markdownIt-Anchor" href="#1安装-ssh-客户端"></a> 1.安装 SSH 客户端</h1>
<p>因 Windows 10 及以上版本基本上默认安装了 SSH 客户端，不需要额外安装，可以使用以下命令检查：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh -V</span><br></pre></td></tr></table></figure>
<p>如出现版本信息则表示 SSH 客户端已安装；没有出现版本信息则需要手动安装，可以使用以下命令安装：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">dism /Online /Add-Capability /CapabilityName:OpenSSH.Client~~~~<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="2生成-ssh-密钥"><a class="markdownIt-Anchor" href="#2生成-ssh-密钥"></a> 2.生成 SSH 密钥</h1>
<p>首先，你需要检查是否已经有 SSH 密钥。在命令行中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>如果存在 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 文件，则表示你已经有了 SSH 密钥。你可以跳过生成 SSH 密钥的步骤。</p>
<p>如果不存在 SSH 密钥，你需要生成一个。在命令行中运行以下命令，并按照提示操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.c</span></span><br></pre></td></tr></table></figure>
<p>将 <code>&quot;your_email@example.com&quot;</code> 替换为你的 GitHub 注册邮箱。在提示你输入文件路径时，直接连按两个 Enter 键即可使用默认路径。</p>
<h1 id="3添加-ssh-密钥到-github-帐户"><a class="markdownIt-Anchor" href="#3添加-ssh-密钥到-github-帐户"></a> 3.添加 SSH 密钥到 GitHub 帐户</h1>
<p>复制你的 SSH 公钥。你可以使用以下命令将公钥打印到终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后，复制输出的 SSH 公钥。</p>
<p>登录到 GitHub 帐户，点击右上角的头像，选择 “Settings”，然后选择 “SSH and GPG keys”。</p>
<p>点击 “New SSH key”，在 “Title” 字段中为该密钥命名（可以任意命名），在 “Key” 字段中粘贴刚刚复制的 SSH 公钥。</p>
<p>点击 “Add SSH key” 以添加密钥。</p>
<h1 id="4验证-ssh-连接"><a class="markdownIt-Anchor" href="#4验证-ssh-连接"></a> 4.验证 SSH 连接</h1>
<p>最后，为了验证 SSH 连接是否正常，你可以在终端中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果一切正常，你将看到一条消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi [你的GitHub用户名]! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>
<p>这条消息表明连接已成功建立，并且你的GitHub用户名被正确识别。</p>
]]></content>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2+Ubuntu+VSCode搭建开发环境</title>
    <url>/2024/05/13/WSL2+Ubuntu+VSCode/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>这里记录一下 WSL2 + Ubuntu22.04 + VSCode 开发环境的搭建过程，以及需要注意的事项。</p>
<h1 id="1安装wsl服务"><a class="markdownIt-Anchor" href="#1安装wsl服务"></a> 1.安装WSL服务</h1>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 自动启用WSL相关功能，安装必要组件，设置WSL2为默认版本</span><br><span class="line">wsl.exe --install</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 更新WSL，否则后续使用WSL可能会报错</span><br><span class="line">wsl.exe --update</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 重启电脑以启动WSL相关功能服务</span><br><span class="line">shutdown /r /t <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="2安装分发版子系统"><a class="markdownIt-Anchor" href="#2安装分发版子系统"></a> 2.安装分发版子系统</h1>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 查看可安装的分发版列表</span><br><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 安装Ubuntu-<span class="number">22</span>.<span class="number">04</span>，选择&lt;NAME&gt;字段中需要的版本即可</span><br><span class="line"># 默认安装在C盘，后续可以迁移到其他盘符中</span><br><span class="line">wsl --install -d Ubuntu-<span class="number">22</span>.<span class="number">04</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 查看ubuntu是否安装成功，出现相关信息即为安装成功</span><br><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<h1 id="3迁移和备份"><a class="markdownIt-Anchor" href="#3迁移和备份"></a> 3.迁移和备份</h1>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 安装时启动了子系统，迁移需要停止子系统</span><br><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 查看子系统状态是否为 &quot;Stopped&quot;</span><br><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 导出子系统镜像</span><br><span class="line">wsl --export Ubuntu-<span class="number">22</span>.<span class="number">04</span> F:\Ubuntu2204\Ubunutu2204.tar</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 注销子系统</span><br><span class="line">wsl --unregister Ubuntu-<span class="number">22</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 使用镜像重新安装子系统到目标文件夹</span><br><span class="line">wsl --import Ubuntu-<span class="number">22</span>.<span class="number">04</span> F:\Ubunutu2204\Ubuntu2204_WLS F:\Ubuntu2204\Ubunutu2204.tar</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 启动WSL服务打开ubuntu开始使用</span><br><span class="line">wsl</span><br></pre></td></tr></table></figure>
<h1 id="4vscode-安装-wsl-插件"><a class="markdownIt-Anchor" href="#4vscode-安装-wsl-插件"></a> 4.VSCode 安装 WSL 插件</h1>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405141716658.png" alt="blog202405141653499" /></p>
<h1 id="5搭建完成"><a class="markdownIt-Anchor" href="#5搭建完成"></a> 5.搭建完成</h1>
<p>进入子系统，使用VSCode打开项目进行开发：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">code ~/project/</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202405141716678.png" alt="blog202405141654850" /></p>
]]></content>
  </entry>
  <entry>
    <title>gcc编译</title>
    <url>/2024/04/23/gcc%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="1gcc-工具安装"><a class="markdownIt-Anchor" href="#1gcc-工具安装"></a> 1.gcc 工具安装</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>
<h1 id="2gcc-编译过程"><a class="markdownIt-Anchor" href="#2gcc-编译过程"></a> 2.gcc 编译过程</h1>
<h2 id="21-预处理"><a class="markdownIt-Anchor" href="#21-预处理"></a> 2.1 预处理</h2>
<p><strong>gcc 在预处理阶段主要做的事情：</strong></p>
<ul>
<li>替换：头文件展开和宏替换</li>
<li>删除：删除注释，多余代码</li>
</ul>
<p><strong>gcc 的预处理指令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E a.c</span><br></pre></td></tr></table></figure>
<p>这个命令运行后不会主动生成文件，而是会将预处理后的内容输出到终端；</p>
<h2 id="22-编译"><a class="markdownIt-Anchor" href="#22-编译"></a> 2.2 编译</h2>
<p><strong>gcc 在编译阶段主要做的事情：</strong></p>
<ul>
<li>检查：检查代码编写符不符合规定</li>
<li>优化：对代码进行优化，以提高它的性能和效率</li>
<li>翻译：将代码翻译为汇编语言</li>
</ul>
<p><strong>gcc 的编译指令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S a.c</span><br></pre></td></tr></table></figure>
<p>命令运行后会自动生成一个 <code>.s</code> 文件，这个文件就是汇编文件；</p>
<h2 id="23-汇编"><a class="markdownIt-Anchor" href="#23-汇编"></a> 2.3 汇编</h2>
<p><strong>gcc 在汇编阶段主要做的事：</strong></p>
<ul>
<li>翻译：将汇编代码翻译为机器码</li>
</ul>
<p><strong>gcc 的汇编指令</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c a.c</span><br></pre></td></tr></table></figure>
<p>命令运行后会自动生成一个 <code>.o</code> 文件，这个文件就是二进制文件；</p>
<h2 id="24-链接"><a class="markdownIt-Anchor" href="#24-链接"></a> 2.4 链接</h2>
<p><strong>gcc 在链接阶段主要做的事：</strong></p>
<ul>
<li>链接：链接各个相关单元</li>
</ul>
<p>gcc 没有单独的链接指令，但生成可执行文件的过程中会自动触发链接操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc a.c</span><br></pre></td></tr></table></figure>
<p>命令运行后会自动生成一个 <code>.out</code> 文件，这个文件就是可执行文件；</p>
<h1 id="3gcc-的动静态编译"><a class="markdownIt-Anchor" href="#3gcc-的动静态编译"></a> 3.gcc 的动静态编译</h1>
<h2 id="31-动态编译和静态编译"><a class="markdownIt-Anchor" href="#31-动态编译和静态编译"></a> 3.1 动态编译和静态编译</h2>
<p><strong>动态编译</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c a.c -o 动态链接.exe</span><br></pre></td></tr></table></figure>
<p>指示动态链接的指令通常是不使用任何特殊选项，因为动态链接是默认行为；</p>
<p><strong>静态编译</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c a.c -o 静态链接.exe -static</span><br></pre></td></tr></table></figure>
<p><code>-static</code> 选项是用来指示编译器在编译链接过程中使用静态链接的，而不是动态链接。</p>
<p><strong>查看动态编译和静态编译文件：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 thui thui  16464 Apr 23 18:17 动态链接.exe</span><br><span class="line">-rwxr-xr-x 1 thui thui 871768 Apr 23 18:17 静态链接.exe</span><br></pre></td></tr></table></figure>
<p>可以看出，静态编译文件比动态编译文件大得多；</p>
<h2 id="32-制作动态库和静态库"><a class="markdownIt-Anchor" href="#32-制作动态库和静态库"></a> 3.2 制作动态库和静态库</h2>
<p><strong>制作动态库指令</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared libexample.so -o example.c</span><br></pre></td></tr></table></figure>
<p>这个命令将会编译 <code>example.c</code> 文件，并生成一个名为 <code>libexample.so</code> 的动态链接库，你可以将这个库链接到其他程序中；</p>
<p><strong>制作静态库指令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar rcs libfoobar.a foo.o bar.o</span><br></pre></td></tr></table></figure>
<p>这个命令将会创建一个名为 <code>libfoobar.a</code> 的静态库文件，其中包含了 <code>foo.o</code> 和 <code>bar.o</code> 两个目标文件；</p>
<h2 id="33-库的链接"><a class="markdownIt-Anchor" href="#33-库的链接"></a> 3.3 库的链接</h2>
<p><strong>库链接命令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main -L&lt;path_to_library&gt; -l&lt;library_name&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在链接动态库时，需要确保系统能够找到并加载所需的动态链接库。可以通过设置 <code>LD_LIBRARY_PATH</code> 环境变量来指定动态库的搜索路径；</p>
]]></content>
  </entry>
  <entry>
    <title>系统编程</title>
    <url>/2024/05/07/%7F%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>​	在学习 Linux 的过程中，在网络上进行搜索，很多的博客或者学习网站都会介绍 Linux 系统编程，其中内容包括文件IO，进程线程，套接字通信等等；有几个点一直很疑惑：到底什么是系统编程？它和 Linux 有什么关系？还有为什么要学习系统编程？在此查阅相关资料学习后进行问题记录。</p>
<h1 id="1系统编程是什么"><a class="markdownIt-Anchor" href="#1系统编程是什么"></a> 1.系统编程是什么？</h1>
<p>系统编程是指利用操作系统提供的功能接口等进行程序开发。</p>
<h1 id="2系统编程的好处是什么"><a class="markdownIt-Anchor" href="#2系统编程的好处是什么"></a> 2.系统编程的好处是什么？</h1>
<p>系统编程的特点就是使用了操作系统的功能接口；当不使用这些功能时，我们所进行的开发基本可以称为裸机开发；裸机开发缺点就是很难开发大型程序，因为大型程序一般涉及到多任务甚至是多主机等；系统编程的好处就体现在提供了一些功能接口，用以帮助开发大型程序，降低开发难度，提高开发效率。</p>
<h1 id="3系统编程主要学习什么"><a class="markdownIt-Anchor" href="#3系统编程主要学习什么"></a> 3.系统编程主要学习什么？</h1>
<p>由上可以看出，系统编程的学习目标是：如何使用操作系统提供的各种功能接口或者工具等进行开发。</p>
<p>Linux 系统编程主要学习的内容有：</p>
<ul>
<li>文件IO：学习文件系统相关功能，包括创建，打开，读写，关闭文件等接口使用。</li>
<li>多任务管理：学习多任务相关功能，包括进程控制，进程通信等接口的使用。</li>
<li>网络编程：学习网络通信相关功能，包括套接字通信接口的使用</li>
<li>Shell脚本编程：学习如何使用 Shell 进行脚本的编写；</li>
<li>其他部分：
<ul>
<li>版本控制工具的使用</li>
<li>各类调试工具和性能优化工具的使用</li>
<li>各类编译工具的使用</li>
<li>各种常用的库和框架</li>
<li>常见的安全漏洞以及攻击手法，能进行代码的安全审查</li>
</ul>
</li>
</ul>
<p>以上就是一个合格的 Linux 应用开发工程师所具备的系统编程知识。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
