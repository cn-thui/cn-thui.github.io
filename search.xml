<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三个数的最大乘积</title>
    <url>/2024/05/17/%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/maximum-product-of-three-numbers/">三个数的最大乘积</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1排序"><a class="markdownIt-Anchor" href="#1排序"></a> 1.排序</h2>
<p><strong>方法与思路</strong>：需要得到三个数乘积的最大值，需要考虑到数组元素的正负问题，全部为正数或负数时返回最大三个元素的乘积，有正数有负数时，需要计算两个最小数与一个最大数的乘积和三个最大数的乘积，最后返回较大值即可；</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(nlogn)，n 为数组的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 计算两个最小数与一个最大数的乘积</span></span><br><span class="line">        <span class="type">int</span> product1 = nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[length - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计算三个最大数的乘积</span></span><br><span class="line">        <span class="type">int</span> product2 = nums[length - <span class="number">1</span>] * nums[length - <span class="number">2</span>] * nums[length - <span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 全部为正或负的情况下，一定返回的是product2，不用单独考虑</span></span><br><span class="line">        <span class="comment">// 返回两者中的较大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(product1, product2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>丢失的数字</title>
    <url>/2024/05/06/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/missing-number/description/">丢失的数字</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [0, n]中元素的和与从 1 加到 n 的和的差值，就是缺失元素的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// i 为 数组元素的位置，从 1 开始</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            ans += i;</span><br><span class="line">            ans -= nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2枚举"><a class="markdownIt-Anchor" href="#2枚举"></a> 2.枚举</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; table;</span><br><span class="line">        <span class="comment">// 创建一个set容器将nums插入进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            table.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组的长度为 n 也就是数组的最大值</span></span><br><span class="line">        <span class="type">int</span> n = table.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 查询 [0, n] 中没有出现的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table.<span class="built_in">find</span>(i) == table.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素I</title>
    <url>/2024/05/09/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/next-greater-element-i/description/">下一个更大元素I</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：在第二个数组中查询第一个数组的元素，然后找到其后方第一个比该元素大的值，并按照要求插入；依次将第一个数组中的元素查找完毕即可。</li>
<li><strong>算法分析</strong>：双层循环，时间复杂度：O（n x m）；不考虑返回数组，使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums1.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nextMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">find</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), nums1[i]);</span><br><span class="line">            <span class="keyword">while</span> (it != nums2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 找到下一个更大的元素，插入元素</span></span><br><span class="line">                <span class="keyword">if</span> (*it &gt; nums1[i]) &#123;</span><br><span class="line">                    nextMax.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历到容器的末尾还没有找到，插入-1</span></span><br><span class="line">                <span class="keyword">if</span> (it == nums2.<span class="built_in">end</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    nextMax.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集</title>
    <url>/2024/05/07/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">两个数组的交集</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建数组存储交集元素</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// 创建哈希表进行条件判断</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化哈希表</span></span><br><span class="line">        hash.<span class="built_in">resize</span>(<span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将第一个数组的元素插入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums1[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 屏蔽第一个数组中相同的元素</span></span><br><span class="line">                hash[nums1[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查第二个数组元素有没有在哈希表中出现，出现则为交集元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length2; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[nums2[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 屏蔽第二个数组中相同的元素</span></span><br><span class="line">                hash[nums2[i]]++;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>两个列表的最小索引总和</title>
    <url>/2024/05/15/%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/minimum-index-sum-of-two-lists/description/">两个列表的最小索引总和</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希条件查找"><a class="markdownIt-Anchor" href="#1哈希条件查找"></a> 1.哈希+条件查找</h2>
<p><strong>方法与思路</strong>：构建一个哈希表，将餐厅名作为键，索引作为值，将第一个数组映射为哈希表；对第二个数组进行遍历，在遍历每一个元素时，都对哈希表进行查找，哈希表中是否存在与当前元素相同的键，如果存在则获取两个元素的索引和，并判断该索引和是否为满足条件索引和的最小值，如果是最小值，则更新最小值并重置数组，如果与之前的最小值相同，则直接将该元素插入。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为两个数组中较长数组的长度</li>
<li>空间复杂度：O(n)，n 为两个数组中较短数组的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="comment">// 将短的数组映射为哈希表，节省内存</span></span><br><span class="line">        vector&lt;string&gt;&amp; shortList = list1.<span class="built_in">size</span>() &lt; list2.<span class="built_in">size</span>() ? list1 : list2;</span><br><span class="line">        vector&lt;string&gt;&amp; longList = list1.<span class="built_in">size</span>() &gt;= list2.<span class="built_in">size</span>() ? list1 : list2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shortList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            hash[shortList[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小索引和</span></span><br><span class="line">        <span class="type">int</span> minIndexSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; longList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 查询到相同的餐厅</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(longList[i])) &#123;</span><br><span class="line">                <span class="type">int</span> indexSum = i + hash[longList[i]];</span><br><span class="line">                <span class="comment">// 判断索引和与最小索引和的关系</span></span><br><span class="line">                <span class="keyword">if</span> (indexSum &lt; minIndexSum) &#123;</span><br><span class="line">                    <span class="comment">// 更新最小索引和并且重置数组</span></span><br><span class="line">                    minIndexSum = indexSum;</span><br><span class="line">                    ans = &#123;longList[i]&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexSum == minIndexSum) &#123;</span><br><span class="line">                    <span class="comment">// 插入数组</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(longList[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集II</title>
    <url>/2024/05/08/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/">两个数组的交集II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> length1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2 = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        hash.<span class="built_in">resize</span>(<span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; i++) &#123;</span><br><span class="line">            <span class="comment">// 记录第一个数组中元素出现的个数</span></span><br><span class="line">            hash[nums1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length2; i++) &#123;</span><br><span class="line">            <span class="comment">// 检查第二个数组元素是否为交集元素</span></span><br><span class="line">            <span class="keyword">if</span> (hash[nums2[i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">                hash[nums2[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2双指针"><a class="markdownIt-Anchor" href="#2双指针"></a> 2.双指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果给定的数组已经排好序呢？你将如何优化你的算法？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设已经排好序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 相同元素插入，否则元素值小的指针先往前走</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2024/04/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/two-sum/description/">两数之和</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1枚举"><a class="markdownIt-Anchor" href="#1枚举"></a> 1.枚举</h2>
<p><strong>思路与方法</strong>：遍历数组，按顺序枚举出两个不同的值，然后求和判断是否等于目标值。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n^2)，n 为 nums 的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">size_t</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2哈希条件查找"><a class="markdownIt-Anchor" href="#2哈希条件查找"></a> 2.哈希+条件查找</h2>
<p><strong>思路与方法</strong>：构建一个哈希表，元素值为键，元素下标为值；开始遍历原数组，在遍历数组的每一个元素时，查询哈希表中是否存在该元素的伙伴，存在则将这两个元素的下标返回，如果不存在则将该元素插入到哈希表中供后续的元素进行查询。</p>
<ul>
<li>如果 b = target - a ，则称 b 为 a 的伙伴</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为 nums 的长度</li>
<li>空间复杂度：O(n)，n 为 nums 的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">size_t</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 查询当前元素在哈希表中是否存在伙伴</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(target - nums[i])) &#123;</span><br><span class="line">                <span class="comment">// 有伙伴，获取两个元素的下标</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(hash[target - nums[i]]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有伙伴，将当前元素插入哈希表中</span></span><br><span class="line">            hash.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2024/04/23/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1枚举"><a class="markdownIt-Anchor" href="#1枚举"></a> 1.枚举</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> numsSize = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 记录最大利润</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">                <span class="comment">// 没有利润直接进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (prices[i] &gt;= prices[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算第i天买入，第j天卖出的利润</span></span><br><span class="line">                <span class="type">int</span> temp = prices[j] - prices[i];</span><br><span class="line">                <span class="comment">// 找出最大利润</span></span><br><span class="line">                <span class="keyword">if</span> (temp &gt; max) &#123;</span><br><span class="line">                    max = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2动态规划"><a class="markdownIt-Anchor" href="#2动态规划"></a> 2.动态规划</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> numsSize = prices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> profit_max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> price_min = prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 每天都看一下今天是不是历史最低点，若是则更新</span></span><br><span class="line">            price_min = <span class="built_in">min</span>(prices[i], price_min);</span><br><span class="line">            <span class="comment">// 每天都看一下我今天卖出能获取的最大利润是多少，如果比以往利润都大则更新</span></span><br><span class="line">            profit_max = <span class="built_in">max</span>(profit_max, prices[i] - price_min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>分糖果</title>
    <url>/2024/05/15/%E5%88%86%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/distribute-candies/description/">分糖果</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希计数"><a class="markdownIt-Anchor" href="#1哈希计数"></a> 1.哈希+计数</h2>
<p><strong>方法与思路</strong>：需要在尽可能少的糖果中吃到尽可能多的类型，我们可以遍历数组，每遇到一种不同的糖果就吃一颗，并且对吃的颗数进行计数；那么出现了子问题：怎么判断糖果的类型不同？可以使用哈希表进行去重，当哈希表中已经记录了这颗糖果时就代表已经吃过了，没记录就代表没吃过；最后在计数的同时判断有没有超过医生建议的数量即可。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为数组长度</li>
<li>空间复杂度：O(n)，n 为构建的哈希表大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = candyType.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 记录吃到不同类型糖果的数量</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 没吃过，可以吃</span></span><br><span class="line">            <span class="keyword">if</span> (hash[candyType[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                hash[candyType[i]]++;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="comment">// 遵循医生建议，最多只吃一半</span></span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2排序计数"><a class="markdownIt-Anchor" href="#2排序计数"></a> 2.排序+计数</h2>
<p><strong>方法与思路</strong>：先将数组进行排序，数组中的糖总是大于两颗的，所以第一颗一定是可以吃的，那么从第二颗开始判断，如果与上一颗糖不同则可以吃，当吃过的糖果数等于医生建议时或数组被遍历完后，返回吃过的不同糖果数。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(nlogn)，n 为排序数组的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = candyType.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 记录吃到不同类型糖果的数量，且假定已经吃了一颗</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(candyType.<span class="built_in">begin</span>(), candyType.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 第一颗总是可以吃的，从第二颗开始判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 与上一颗不同，可以吃</span></span><br><span class="line">            <span class="keyword">if</span> (candyType[i] != candyType[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= length / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>分发饼干</title>
    <url>/2024/05/08/%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/assign-cookies/description/">分发饼干</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何能满足满足最多的小孩？为每个小孩找到一个能满足胃口且最合适的饼干就可以满足尽量多的小孩；如果按照顺序来分，那么没有被分配出去且刚好能满足胃口的饼干就是最合适的饼干；可以从小到大分，也可以从大到小分。</li>
<li><strong>算法分析</strong>：使用了排序算法，时间复杂度：O（nlogn），其次使用了循环，时间复杂度：O（n），综合来看时间复杂度为：O（nlogn），其中 n 为 g 或 s 数组长度的较大值；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 双指针，分别指向小孩和饼干</span></span><br><span class="line">        <span class="type">int</span> indexG = <span class="number">0</span>， indexS = <span class="number">0</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 退出条件为已经没有饼干可以满足后面的小孩了或者是每个小孩都被满足了</span></span><br><span class="line">        <span class="keyword">while</span> (indexS &lt; s.<span class="built_in">size</span>() &amp;&amp; indexG &lt; g.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[indexS] &gt;= g[indexG]) &#123;</span><br><span class="line">                <span class="comment">// 满足了小孩，开始为下一个小孩寻找饼干，满足人数加一</span></span><br><span class="line">                indexG++;</span><br><span class="line">                indexS++;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没满足小孩，看看下一个饼干是否可以满足</span></span><br><span class="line">                indexS++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>删除有序数组中的重复项</title>
    <url>/2024/04/20/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">删除有序数组中的重复项</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> slow_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fast_index = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 结束条件为快指针走到了数组的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast_index &lt; numsSize) &#123;</span><br><span class="line">        <span class="comment">// 如果慢指针比快指针的值小，则将快指针的值填充进慢指针的后面</span></span><br><span class="line">        <span class="keyword">if</span> (nums[slow_index] &lt; nums[fast_index]) &#123;</span><br><span class="line">            nums[++slow_index] = nums[fast_index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果慢指针与快指针的值相同，则快指针往前走，慢指针不动</span></span><br><span class="line">        fast_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组元素的个数等于数组最后一个元素索引加一</span></span><br><span class="line">    <span class="type">int</span> ans = slow_index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2024/04/20/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/plus-one/description/">加一</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">plusOne</span><span class="params">(<span class="type">int</span>* digits, <span class="type">int</span> digitsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    *returnSize = digitsSize;</span><br><span class="line">    <span class="comment">// 逆序遍历数组元素，判定是否需要增加数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = digitsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                *returnSize = digitsSize + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请内存用以存储新数组</span></span><br><span class="line">    <span class="type">int</span>* ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组长度需要增加，此时只有第一个元素为1，其他元素都为0</span></span><br><span class="line">    <span class="keyword">if</span> (*returnSize &gt; digitsSize) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要增加，将原数组数组拷贝到 ans 中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ans, digits, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (*returnSize));</span><br><span class="line">    <span class="comment">// 逆序遍历元素进行修改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = *returnSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">9</span>) &#123;</span><br><span class="line">            ans[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>区间加法II</title>
    <url>/2024/05/15/%E5%8C%BA%E9%97%B4%E5%8A%A0%E6%B3%95II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/range-addition-ii/description/">区间加法II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<p><strong>方法与思路</strong>：对于每一次操作都需要对指定区间进行加一，每次操作都覆盖到的区域即为矩阵中的最大值，对于操作数来说，每次操作都能覆盖的范围其实就是操作数中的最小值，只需要遍历数组找到行和列对应操作数的最小值即可。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为 ops 的行数</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> rows = ops.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到行操作数的最小值</span></span><br><span class="line">           	m = <span class="built_in">min</span>(m, ops[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 找到列操作数的最小值</span></span><br><span class="line">            n = <span class="built_in">min</span>(n, ops[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>区域和检索-数组不可变</title>
    <url>/2024/05/07/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/">区域和检索-数组不可变</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1前缀和"><a class="markdownIt-Anchor" href="#1前缀和"></a> 1.前缀和</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化前缀和数组，长度比原数组长度多 1</span></span><br><span class="line">        arr.<span class="built_in">resize</span>(length + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化时遍历数组计算前缀和</span></span><br><span class="line">            arr[i + <span class="number">1</span>] = arr[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (arr[right + <span class="number">1</span>] - arr[left]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2枚举"><a class="markdownIt-Anchor" href="#2枚举"></a> 2.枚举</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        arr.<span class="built_in">resize</span>(length, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            arr[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的的数字</title>
    <url>/2024/04/28/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/single-number/description/">只出现一次的数字</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1异或运算"><a class="markdownIt-Anchor" href="#1异或运算"></a> 1.异或运算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 两个相等的值异或等于0</span></span><br><span class="line">            ans ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2024/04/28/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/majority-element/description/">多数元素</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1摩尔投票"><a class="markdownIt-Anchor" href="#1摩尔投票"></a> 1.摩尔投票</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录票数</span></span><br><span class="line">        <span class="type">int</span> votes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录众数值</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 票数抵消为0时，将众数更新为当前元素</span></span><br><span class="line">                ans = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == ans) &#123;</span><br><span class="line">                <span class="comment">// 如果当前元素为众数，则票数+1</span></span><br><span class="line">                votes++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前元素不为众数，则票数-1</span></span><br><span class="line">                votes--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/2024/04/22/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针从头开始填充"><a class="markdownIt-Anchor" href="#1双指针从头开始填充"></a> 1.双指针（从头开始填充）</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理特殊情况****************************/</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums2.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m - <span class="number">1</span>] &lt; nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[<span class="number">0</span>] &gt; nums2[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + <span class="number">0</span>, nums1.<span class="built_in">begin</span>() + m, nums1.<span class="built_in">begin</span>() + n);</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理一般情况****************************/</span></span><br><span class="line">        <span class="type">int</span> length = m + n;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        nums.<span class="built_in">resize</span>(length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束条件为其中一个数组已经填充完毕</span></span><br><span class="line">        <span class="keyword">while</span> (index1 ！= m &amp;&amp; index2 != n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[index1] &lt;= nums2[index2]) &#123;</span><br><span class="line">                nums[index++] = nums1[index1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">                nums[index++] = nums2[index2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组1填充完毕，将数组2剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + index2, nums2.<span class="built_in">begin</span>() + n,</span><br><span class="line">                      nums.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组2填充完毕，将数组1剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + index1, nums1.<span class="built_in">begin</span>() + m,</span><br><span class="line">                      nums.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将合并后的数组拷贝到数组1中</span></span><br><span class="line">        <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2双指针从尾开始填充"><a class="markdownIt-Anchor" href="#2双指针从尾开始填充"></a> 2.双指针（从尾开始填充）</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理特殊情况****************************/</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums2.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m - <span class="number">1</span>] &lt; nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[<span class="number">0</span>] &gt; nums2[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + <span class="number">0</span>, nums1.<span class="built_in">begin</span>() + m, nums1.<span class="built_in">begin</span>() + n);</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******************************处理一般情况****************************/</span></span><br><span class="line">        <span class="type">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index2 = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束条件为某个数组已经填充完毕</span></span><br><span class="line">        <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> &amp;&amp; index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[index1] &gt;= nums2[index2]) &#123;</span><br><span class="line">                nums1[index--] = nums1[index1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[index--] = nums2[index2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组1填充完毕，将数组2剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[index--] = nums2[index2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组2填充完毕，将数组1剩余的数据填充</span></span><br><span class="line">        <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[index--] = nums1[index1--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3排序"><a class="markdownIt-Anchor" href="#3排序"></a> 3.排序</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(nums1.<span class="built_in">data</span>(), nums2.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[m - <span class="number">1</span>] &lt; nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[<span class="number">0</span>] &gt; nums2[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            std::<span class="built_in">copy</span>(nums1.<span class="built_in">begin</span>() + <span class="number">0</span>, nums1.<span class="built_in">begin</span>() + m, nums1.<span class="built_in">begin</span>() + n);</span><br><span class="line">            std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理一般情况</span></span><br><span class="line">        std::<span class="built_in">copy</span>(nums2.<span class="built_in">begin</span>() + <span class="number">0</span>, nums2.<span class="built_in">begin</span>() + n, nums1.<span class="built_in">begin</span>() + m);</span><br><span class="line">        std::<span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素II</title>
    <url>/2024/04/29/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/">存在重复元素II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(nums[i]) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 找到相同值，返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没找到，插入键值</span></span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                <span class="comment">// 窗口开始滑动，擦除窗口外的值</span></span><br><span class="line">                hash.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2024/04/29/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/contains-duplicate/description/">存在重复元素</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希表"><a class="markdownIt-Anchor" href="#1哈希表"></a> 1.哈希表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(i) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 找到了相同值，返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没找到，插入到尾部</span></span><br><span class="line">            hash.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有相同的值，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>找到所有数组中消失的数字</title>
    <url>/2024/05/08/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">找到所有数组中消失的数字</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希预处理遍历搜索"><a class="markdownIt-Anchor" href="#1哈希预处理遍历搜索"></a> 1.哈希预处理+遍历+搜索</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="comment">// 数组的长度 = 数组的最大值 = 区间的最大值</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            hash[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿的周长</title>
    <url>/2024/05/08/%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/island-perimeter/description/">岛屿的周长</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：一个格子有四条边，如果上下左右有一方相邻则减少一条边，那么在遍历数组为陆地时需要处理子问题：当前陆地的上下左右是否为陆地，如果为陆地则减少一条边；陆地与陆地的相邻是相互的，所以判断一个陆地上方有相邻时，上方陆地也会判断出下方陆地相邻，那么上下判断可以只执行其一，减少一条边变为减少两条边（减少的一条边为当前格子的边，另一条边为相邻格子的边），左右同理；所以只需要遍历每个格子并判断右方和下方是否有相邻的陆地，并进行边的计算，最后累加完就是岛屿的周长。</li>
<li><strong>算法分析</strong>：遍历二维数组，时间复杂度：O（m × n）；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rows = grid.<span class="built_in">size</span>(), cols = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前元素为陆地，添加四条边并进行右方和下方判断</span></span><br><span class="line">                    cnt += <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i != rows - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                            cnt -= <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j != cols - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                            cnt -= <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>将有序数组转换为二叉搜索树</title>
    <url>/2024/04/22/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">将有序数组转换为二叉搜索树</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1中序遍历"><a class="markdownIt-Anchor" href="#1中序遍历"></a> 1.中序遍历</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">function</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右相遇时结束递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取中间元素索引</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 创建节点，并初始化值为中间元素的值</span></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        <span class="comment">// 递归获取节点的左子节点</span></span><br><span class="line">        node-&gt;left = <span class="built_in">function</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归获取节点的右子节点</span></span><br><span class="line">        node-&gt;right = <span class="built_in">function</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">function</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>提莫攻击</title>
    <url>/2024/05/09/%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/teemo-attacking/description/">提莫攻击</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何得到艾希的总中毒时间？当艾希中毒后的中毒时间内没有再次中毒，那么中毒时间就是完整的；当艾希中毒后中毒时间内又再次中毒，那么中毒时间不完整，需要进行计算；最终将每次中毒的时间进行累加就可以得到艾希的总中毒时间。</li>
<li><strong>算法分析</strong>：只需要一次遍历，时间复杂度：O（n）；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPoisonedDuration</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; timeSeries, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = timeSeries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sumTime = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算第一次中毒的结束时间</span></span><br><span class="line">        <span class="type">int</span> endTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算中毒的结束时间</span></span><br><span class="line">            endTime = timeSeries[i] + duration - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (endTime &lt; timeSeries[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 中毒时间完整</span></span><br><span class="line">                sumTime += duration;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中毒时间不完整</span></span><br><span class="line">                sumTime = sumTime + timeSeries[i + <span class="number">1</span>] - timeSeries[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一次攻击完后中毒时间总是完整的</span></span><br><span class="line">        sumTime += duration;</span><br><span class="line">        <span class="keyword">return</span> sumTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索插入位置</title>
    <url>/2024/04/20/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/search-insert-position/description/">搜索插入位置</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1二分查找"><a class="markdownIt-Anchor" href="#1二分查找"></a> 1.二分查找</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(x, y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 获取中间索引</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 更新右边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 更新左边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回目标值的索引</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回插入位置的索引</span></span><br><span class="line">    <span class="keyword">return</span> MIN(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 目标值小于数组最小值</span></span><br><span class="line">    <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 目标值大于数组最大值</span></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[numsSize - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>数组拆分</title>
    <url>/2024/05/13/%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/array-partition/description/">数组拆分</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1排序贪心"><a class="markdownIt-Anchor" href="#1排序贪心"></a> 1.排序+贪心</h2>
<ul>
<li><strong>算法思路</strong>：如何获得总和最大？每一个数对中都会取较小的值，而另外一个值则一定排除再外，那么我只需要给这个数匹配一个大于它且最接近的数，那么这样的话，最小的值应该匹配第二小的值，剩下的数同理分析，所以将数组进行排序后可以发现，累加到和中的数字其实就是数组中偶数下标对应的元素。</li>
<li><strong>算法分析</strong>：sort() 函数底层使用快速排序或者堆排序，时间复杂度：O（nlogn），循环遍历时间复杂度：O（n），综合来看时间复杂度：O（nlogn）；使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arrayPairSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            minSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最大连续1的个数</title>
    <url>/2024/05/08/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones/description/">最大连续1的个数</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何得到最大连续 1 的个数？将连续为 1 的数段累加后与当前出现最大的连续 1 的个数进行比较，如果超过则更新出现最大的连续 1 的个数，如果没超过继续遍历数组，如果为 0 则累加的值作废；</li>
<li><strong>算法分析</strong>：只需要一次遍历，时间复杂度：O（n），使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                max = cnt &gt; max ? cnt : max;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角</title>
    <url>/2024/04/22/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/pascals-triangle/description/">杨辉三角</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化行容器的大小</span></span><br><span class="line">            nums[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 初始化行第一个元素和最后一个元素为1</span></span><br><span class="line">            nums[i][<span class="number">0</span>] = nums[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找到每一行的中间靠右元素的下标</span></span><br><span class="line">            <span class="type">int</span> mid_right = (i / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算需要填充数据位置及其大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; mid_right; j++) &#123;</span><br><span class="line">                nums[i][j] = nums[i][i - j] =</span><br><span class="line">                    nums[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2024/05/15/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/longest-harmonious-subsequence/description/">最长和谐子序列</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1哈希条件查找"><a class="markdownIt-Anchor" href="#1哈希条件查找"></a> 1.哈希+条件查找</h2>
<p><strong>方法与思路</strong>：首先构建一个哈希表，键为原数组元素的值，值为该元素出现的次数；将原数组映射为哈希表后，对哈希表进行遍历，在遍历每一个元素时，查询哈希表中是否存在该元素的伙伴，如果存在则获取两个元素出现次数的和，满足条件和中的最大值即为最长子序列的长度。</p>
<ul>
<li>如果 b = a + 1，则称 b 为 a 的伙伴</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为 nums 的长度</li>
<li>空间复杂度：O(n)，n 为 nums 的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建哈希表</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            hash[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : hash) &#123;</span><br><span class="line">            <span class="comment">// 查询当前元素是否有伙伴</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(it.first + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 获取这对元素构成的子序列长度</span></span><br><span class="line">                <span class="type">int</span> sum = it.second + hash[it.first + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 获取最长子序列的长度</span></span><br><span class="line">                ans = sum &gt; ans ? sum : ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角II</title>
    <url>/2024/04/23/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">杨辉三角II</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1原理计算"><a class="markdownIt-Anchor" href="#1原理计算"></a> 1.原理计算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 生成一个 newRows 行的杨辉三角并返回</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化行容器的大小</span></span><br><span class="line">            nums[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 初始化行第一个元素和最后一个元素为1</span></span><br><span class="line">            nums[i][<span class="number">0</span>] = nums[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找到每一行的中间靠右元素的下标</span></span><br><span class="line">            <span class="type">int</span> mid_right = (i / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算需要填充数据位置及其大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; mid_right; j++) &#123;</span><br><span class="line">                nums[i][j] = nums[i][i - j] =</span><br><span class="line">                    nums[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取需要构建杨辉三角的大小</span></span><br><span class="line">        <span class="type">int</span> size = rowIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 声明一个二维容器用来接收生成的杨辉三角</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(size);</span><br><span class="line">        <span class="comment">// 调用函数生成杨辉三角并接收</span></span><br><span class="line">        nums = <span class="built_in">generate</span>(size);</span><br><span class="line">        <span class="comment">// 返回目标行</span></span><br><span class="line">        <span class="keyword">return</span> nums[rowIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>汇总区间</title>
    <url>/2024/04/29/%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/summary-ranges/description/">汇总区间</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 记录区间头</span></span><br><span class="line">            <span class="type">int</span> front = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录区间尾</span></span><br><span class="line">            <span class="type">int</span> end = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (front &lt; end) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[front]) + <span class="string">&quot;-&gt;&quot;</span> +</span><br><span class="line">                              <span class="built_in">to_string</span>(nums[end]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[front]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>相对名次</title>
    <url>/2024/05/12/%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/relative-ranks/description/">相对名次</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2>
<ul>
<li><strong>算法思路</strong>：如何获取每位运动员的名次？可以按顺序进行查找，先找到分数最高的运动员进行颁奖，然后找到分数第二的进行颁奖，直到每位运动员都拿到对应的名次为止。</li>
<li><strong>算法分析</strong>：双循环遍历，时间复杂度：O（n^2）；不考虑返回数组，使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组的长度 = 运动员的个数 = 运动员的最低名次</span></span><br><span class="line">        <span class="type">int</span> length = score.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        ans.<span class="built_in">resize</span>(length, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找出获得第 i 名的运动员</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">            <span class="comment">// 找出该名运动员对应的下标</span></span><br><span class="line">            <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (score[j] &gt; score[n]) &#123;</span><br><span class="line">                    n = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 给出这名运动员的名次 i 所对应的奖励</span></span><br><span class="line">            <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: ans[n] = <span class="string">&quot;Gold Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: ans[n] = <span class="string">&quot;Silver Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: ans[n] = <span class="string">&quot;Bronze Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: ans[n] = <span class="built_in">to_string</span>(i); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 抹除掉这名运动员成绩</span></span><br><span class="line">            score[n] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="哈希排序"><a class="markdownIt-Anchor" href="#哈希排序"></a> 哈希+排序</h2>
<ul>
<li><strong>算法思路</strong>：如何获取每位运动员的名次？可以将分数进行排序，然后依次分配名次，但是分配名次时需要知道成绩对应的运动员信息，可以使用哈希表，将分数作为键，将运动员信息作为值，然后对键进行排序，然后依次分配名次，分配名次时获取运动员信息即可。</li>
<li><strong>算法分析</strong>：map 插入函数的底层基于红黑树实现，时间复杂度：O（log n），循环遍历时间复杂度：O（n），综合来看时间复杂度：O（n）；不考虑返回数组，构建了一个哈希表，空间复杂度：O（n）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组的长度 = 运动员的个数 = 运动员的最低名次</span></span><br><span class="line">        <span class="type">int</span> length = score.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        ans.<span class="built_in">resize</span>(length, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="comment">// 使用map构建哈希表，因为map会自动根据键的大小进行排序</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(score[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为遍历map时从最小值开始，所以从最低名次开始分配</span></span><br><span class="line">        <span class="type">int</span> i = length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : hash) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: ans[it.second] = <span class="string">&quot;Gold Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: ans[it.second] = <span class="string">&quot;Silver Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: ans[it.second] = <span class="string">&quot;Bronze Medal&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: ans[it.second] = <span class="built_in">to_string</span>(i); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>移动0</title>
    <url>/2024/05/07/%E7%A7%BB%E5%8A%A80/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/move-zeroes/description/">移动0</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 顺序查找为 0 的元素，不为 0 则退出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 与 i 后第一个不为0的元素进行交换</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2动态规划"><a class="markdownIt-Anchor" href="#2动态规划"></a> 2.动态规划</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录 0 的个数，也就是元素需要移动的距离</span></span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 当前元素为 0，不需要移动直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前不需要移动，直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将元素向前移动 n 个单位，并将该位置置为 0</span></span><br><span class="line">            nums[i - n] = nums[i];</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>种花问题</title>
    <url>/2024/05/16/%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/can-place-flowers/description/">种花问题</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1贪心"><a class="markdownIt-Anchor" href="#1贪心"></a> 1.贪心</h2>
<p><strong>方法与思路</strong>：假设花坛中有一段连续的地块没有花，连续地块的数量为 n ，这个连续的地块最多可以种植 ( ( ( n - 2 ) + 1 ) / 2 ) 朵花；但如果地块处于花坛的头部或者尾部，则最多可以种植 ( ( ( n - 1 ) + 1 ) / 2 ) 朵花，那么只需要找出花坛中有多少个这样的连续地块并获取每一个连续地块的数量 n 进行计算即可；</p>
<ul>
<li>为了统一计算方式为 ( ( ( n - 2 ) + 1 ) / 2 )，我们可以在找到头部或者尾部地块时多加一个地块，在计算时扣除掉即可</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前地块没有花</span></span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; i == length - <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> || i == length - <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前已经是最后一个地块或下一个地块有花，需要进行计算</span></span><br><span class="line">            <span class="keyword">if</span> (i == length - <span class="number">1</span> || flowerbed[i + <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    sum += (cnt - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> ans = (sum &gt;= n ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>移除元素</title>
    <url>/2024/04/20/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1双指针"><a class="markdownIt-Anchor" href="#1双指针"></a> 1.双指针</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 从左开始从查找值为 val 的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] != val) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右开始查找值不为 val 的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[right] == val) &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将左右调换</span></span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边界与右边界相遇时即为左边界即为数组修改后的长度</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>重塑矩阵</title>
    <url>/2024/05/13/%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/reshape-the-matrix/description/">重塑矩阵</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1flatten映射"><a class="markdownIt-Anchor" href="#1flatten映射"></a> 1.flatten映射</h2>
<p><strong>方法与思路</strong>：用两个下标进行标注，遍历原数组的元素插入重塑数组，当重塑数组的第一行插入满了以后切换进入下一行，直到插入完毕为止，先将原数组映射为一维数组，获得其下标，将下标再映射为目标数组，因为映射计算是可逆的，所以可以直接将原数组赋值给目标数组。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，n 为二维向量中的元素个数</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span> rows = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(rows * cols != r * c)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">againArr</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++) &#123;</span><br><span class="line">            <span class="comment">// 行 = 一维数组下标 / 最大列</span></span><br><span class="line">            <span class="comment">// 列 = 一维数组下标 % 最大列</span></span><br><span class="line">            againArr[i / c][i % c] = mat[i / cols][i % cols];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> againArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>第三大的数</title>
    <url>/2024/05/08/%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/third-maximum-number/description/">第三大的数</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<h2 id="1动态规划"><a class="markdownIt-Anchor" href="#1动态规划"></a> 1.动态规划</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 保证三个数比数组中任何元素都小</span></span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> first = LONG_MIN;</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> secend = LONG_MIN;</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> third = LONG_MIN;</span><br><span class="line">        <span class="comment">// 记录更新次数</span></span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 去重，不进行更新</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == first || nums[i] == secend || nums[i] == third) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据遍历元素的大小进行更新</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; first) &#123;</span><br><span class="line">                third = secend;</span><br><span class="line">                secend = first;</span><br><span class="line">                first = nums[i];</span><br><span class="line">                n++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; secend) &#123;</span><br><span class="line">                third = secend;</span><br><span class="line">                secend = nums[i];</span><br><span class="line">                n++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; third) &#123;</span><br><span class="line">                third = nums[i];</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当更新次数小于3时说明没有第三大的数字，按要求返回</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>键盘行</title>
    <url>/2024/05/11/%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="原题"><a class="markdownIt-Anchor" href="#原题"></a> 原题</h1>
<ul>
<li><a href="https://leetcode.cn/problems/keyboard-row/description/">键盘行</a></li>
</ul>
<h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1>
<ul>
<li><strong>算法思路</strong>：如何只返回可以使用键盘同一行打印的单词？首先需要遍历每个单词，并对每个单词的每个字符判定，是否属于同一行，如果是则存储返回数组，不是则开始遍历下一个单词；此时需要解决两个子问题：（1）怎么获取到单词中字符的行号？（2）怎么判定字符属于同一行？先解决第一个问题：使用一个数组哈希，使用 26 个字母的 ASCII 值减去小写字母 a 的 ASCII 值即为数组的下标，而下标对应的元素的值为该字母所属的行号，那么在获取到字符时先转换为小写，然后获取其 ASCII 值并进行计算就可以获取该字符的行号；第二个问题：如果使用字符两两判定实现起来太过复杂，将问题转为，当字符串中的每个字符都和第一个字符在同一行时，那么这个字符串就是符合要求的，然后循环进行判定即可。</li>
<li><strong>算法分析</strong>：需要遍历所有的字符，时间复杂度：O（n），n 为字符串数组中所有字符的个数；除开返回数组外，使用常数空间，空间复杂度：O（1）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储符合要求的字符串</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="comment">// 数组哈希</span></span><br><span class="line">        string rowIndex = <span class="string">&quot;12210111011122000010020202&quot;</span>;</span><br><span class="line">        <span class="comment">// 循环遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 创建标志位判断该字符串是否符合要求</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 获取字符串第一个字符所在的行号</span></span><br><span class="line">            <span class="type">char</span> startLine = rowIndex[<span class="built_in">tolower</span>(words[i][<span class="number">0</span>]) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="comment">// 循环遍历字符串中的每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 判定字符是否与第一个字符属于同一行</span></span><br><span class="line">                <span class="keyword">if</span> (rowIndex[<span class="built_in">tolower</span>(words[i][j]) - <span class="string">&#x27;a&#x27;</span>] != startLine) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个字符串判定结束后，将符合要求的字符串插入返回数组</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>NAND闪存基础</title>
    <url>/2024/06/16/NAND%E9%97%AA%E5%AD%98%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-闪存基础"><a class="markdownIt-Anchor" href="#1-闪存基础"></a> 1、闪存基础</h1>
<h2 id="11-闪存是什么"><a class="markdownIt-Anchor" href="#11-闪存是什么"></a> 1.1 闪存是什么？</h2>
<p>闪存称 Flash Memory，是一种非易失性存储器，非易失性存储器可以在没有电源供应的情况下长时间的保存数据。</p>
<h2 id="12-闪存如何保存数据"><a class="markdownIt-Anchor" href="#12-闪存如何保存数据"></a> 1.2 闪存如何保存数据？</h2>
<p>闪存基于 EEPROM 技术，通过浮栅晶体管来保存二进制信息，其信息写入和读取通过电压进行控制。</p>
<h2 id="13-浮栅晶体管是什么"><a class="markdownIt-Anchor" href="#13-浮栅晶体管是什么"></a> 1.3 浮栅晶体管是什么？</h2>
<p>浮栅晶体管是一种金属氧化物半导体场效应管（MOSFET），它的结构类似于传统的 MOSFET：</p>
<img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202406062345158.png" style="zoom:50%;" />
<ul>
<li><strong>Control gate（控制栅极）</strong></li>
<li><strong>Isolator（绝缘层）</strong></li>
<li><strong>Floating gate（浮栅）</strong></li>
<li><strong>Source（源极）</strong></li>
<li><strong>Drain（漏极）</strong></li>
<li><strong>n-channel（n沟道）</strong></li>
<li><strong>Substrate（衬底）</strong></li>
</ul>
<h2 id="14-浮栅晶体管是如何保存数据的"><a class="markdownIt-Anchor" href="#14-浮栅晶体管是如何保存数据的"></a> 1.4 浮栅晶体管是如何保存数据的？</h2>
<p>浮栅晶体管中的浮栅可以长时间的保存电子，而其上下两层绝缘层可以保证在掉电后浮栅中的电荷不会流失，可以通过将电子注入进浮栅来保存信息。</p>
<h2 id="15-如何将电子注入浮栅中"><a class="markdownIt-Anchor" href="#15-如何将电子注入浮栅中"></a> 1.5 如何将电子注入浮栅中？</h2>
<p>正常情况下电子是无法通过绝缘层的，但如果在绝缘层两端加上一个大电压（编程电压），电子就会发生量子隧道效应（也称隧穿效应）穿过绝缘层。在浮栅晶体管中，通过在控制栅极和衬底间加入一个大电压，电子会因为电场作用到达沟道中，并发生隧穿效应到达浮栅，这个过程就是写入的原理。反过来，当电子在浮栅中时，给其内部加入一个反向的大电压（擦除电压），电子就可以从浮栅达到沟道，这就是擦除的原理。</p>
<h2 id="16-如何读取数据"><a class="markdownIt-Anchor" href="#16-如何读取数据"></a> 1.6 如何读取数据？</h2>
<p>首先需要明确二进制信息与浮栅中电子数量的关系。假设给控制栅极和衬底中加入一个小电压（读取电压），电子会在弱电场的作用下达到沟道中，但不足以发生隧穿效应；然后在漏极和源极中也施加一个小电压（读取电压），测量这些电子是否足以让晶体管导通，衬底中的电子足够多时晶体管会导通，此时进入浮栅中的电子非常少，这个状态对应二进制状态 1；不导通则说明衬底中的电子很少，大部分电子进入到了浮栅中，这个状态对应二进制状态 0。其对应关系为：</p>
<table>
<thead>
<tr>
<th>二进制信息</th>
<th>晶体管导通</th>
<th>浮栅中电子数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>不导通</td>
<td>多</td>
</tr>
<tr>
<td>1</td>
<td>导通</td>
<td>少</td>
</tr>
</tbody>
</table>
<h2 id="17-如何保存生活中信息"><a class="markdownIt-Anchor" href="#17-如何保存生活中信息"></a> 1.7 如何保存生活中信息？</h2>
<p>了解浮栅晶体管的原理后，浮栅晶体管通常只可以保存 1bit 的信息，显然这是不足以保存生活中的信息，但将成千上万个浮栅晶体管进行组织排列并通过特定的方式进行控制，将生活中的信息转换为二进制信息后，按照一定的顺序保存到不同的浮栅晶体管中即可；读取数据时再将这些浮栅晶体管中的数据按照相同的顺序组织起来转化为生活中的信息即可。</p>
<h2 id="18-如何控制多个浮栅晶体管"><a class="markdownIt-Anchor" href="#18-如何控制多个浮栅晶体管"></a> 1.8 如何控制多个浮栅晶体管？</h2>
<p>闪存由成千上万个浮栅晶体管组成，在写入数据或读取数据时，需要指定其中一个晶体管控制它的衬底、漏极、源极和控制栅极的电压，最简单的控制方法就是给每一个晶体管的衬底、漏极、源极和控制栅极分别接一根线，当需要控制这个晶体管时就操作这个浮栅晶体管相关的线。在闪存的设计中，衬底和漏极连接在一起，它们接入的线称为源线（Source Line, SL），漏极接入的线称为位线（Bit Line, BL），控制栅极接入的线称为字线（Word Line, WL）。在需要控制某个浮栅晶体管时就找到该晶体管对应的三根线，并控制其电压进行写入数据或读取数据。</p>
<h1 id="2-nand基础"><a class="markdownIt-Anchor" href="#2-nand基础"></a> 2、NAND基础</h1>
<h2 id="21-nand是什么"><a class="markdownIt-Anchor" href="#21-nand是什么"></a> 2.1 NAND是什么？</h2>
<p>NAND 是闪存的一中类型，准确来说，NAND 是闪存组织和排列浮栅晶体管的一种方式，其独特的排列结构和组织结构使其具有独特的优点。</p>
<h2 id="22-nand如何排列"><a class="markdownIt-Anchor" href="#22-nand如何排列"></a> 2.2 NAND如何排列？</h2>
<p>NAND 以一种串联的形式组织浮栅晶体管，其结构示意图如下：</p>
<img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/202406161847572.png" style="zoom: 80%;" />
<p>第一行和最后一行是传统的晶体管，而中间行则是由浮栅晶体管组成，这便是 NAND 晶体管的排列结构，也称为存储阵列。其中 BSL (Bit Select Line) 和 GSL (Ground Select Line) 的作用是用于选择不同的存储阵列。</p>
<h2 id="23-nand如何组织"><a class="markdownIt-Anchor" href="#23-nand如何组织"></a> 2.3 NAND如何组织？</h2>
<p>NAND 的组织结构结构示意图为：</p>
<img src="https://cdn.jsdelivr.net/gh/cn-thui/image_source@master/hexo/blog202406062345161.png"  />
<p>CHIP 就是一个闪存芯片，而中间的小方块则被称为一个 DIE 或 LUN，每个 DIE 中又划分为多个 Plane ，每个 Plane 又划分出多个 Block，而 Block 正是一个存储阵列，存储阵列中的由一根字线连接起来的所有浮栅晶体管被称为一个 Page。</p>
<h2 id="24-nand结构有什么优缺点"><a class="markdownIt-Anchor" href="#24-nand结构有什么优缺点"></a> 2.4 NAND结构有什么优缺点？</h2>
<p>这种闪存结构被称为 2D NAND，它结构的优点在于不需要在每一个浮栅晶体管上接三根线，其减少了金属导线的面积，在相同的存储面积下可以容纳更多的浮栅晶体管，提高闪存的存储密度，其结构的制作工艺也相对简单，其制造成本更低。其缺点在于由于复杂的结构，浮栅晶体管的地址编码解码变得更加困难，读写所需要的时间也更多，所以在读写性能上表现不突出，适用于存储数据场景而非频繁读写的场景。</p>
]]></content>
      <categories>
        <category>存储开发</category>
        <category>NAND Flsh</category>
      </categories>
      <tags>
        <tag>NAND Flash</tag>
      </tags>
  </entry>
</search>
